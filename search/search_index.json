{
    "docs": [
        {
            "location": "/",
            "text": "Welcome to self-dsl\n\n\nThis is a tutorial site for the creation of domain specific languages.\n\n\n\n\n\n\nMotivation\n:\n    Why using a DSL? What is the value of it? What is MDSD?\n\n\n\n\n\n\nBasics of meta modeling\n\n    What is meta modeled?\n\n\n\n\n\n\nTutorial-like topics for Xtext and TextX (see sidebar).\n\n\n\n\n\n\nReferences\n\n\n\n\n\n\nDevelopment, Sources, License\n\n\nSee: \ngithub sources\n\n\nEmployed software to generate this documentation\n\n\n\n\nWe use \nMkDocs\n to build these\npages (using the \nRead the Docs\n\ntheme).\n\n\nWe employ \nPlantUML\n to produce UML graphics\n(together with a \nplugin\n\nworking together with  \nMkDocs\n).",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#welcome-to-self-dsl",
            "text": "This is a tutorial site for the creation of domain specific languages.    Motivation :\n    Why using a DSL? What is the value of it? What is MDSD?    Basics of meta modeling \n    What is meta modeled?    Tutorial-like topics for Xtext and TextX (see sidebar).    References",
            "title": "Welcome to self-dsl"
        },
        {
            "location": "/#development-sources-license",
            "text": "See:  github sources",
            "title": "Development, Sources, License"
        },
        {
            "location": "/#employed-software-to-generate-this-documentation",
            "text": "We use  MkDocs  to build these\npages (using the  Read the Docs \ntheme).  We employ  PlantUML  to produce UML graphics\n(together with a  plugin \nworking together with   MkDocs ).",
            "title": "Employed software to generate this documentation"
        },
        {
            "location": "/motivation/",
            "text": "Motivation\n\n\nThe problem to be solved is two-fold: avoid problems with\n\ncommunication\n and \nconsistency\n.\nA \ncommon language\n will be defined to ease \ncommunication\n within and\nbetween teams. A \nsingle source\n of information implies \nconsistency\n,\nand in turn, prevents misunderstandings.\n\n\n\n\nA very good introduction to domain modeling is\n\n(Tomassetti, 2017)\n.\n\n\nMDSD and DSLs\n\n\nModel driven software development (MDSD)\n allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\ncomplement, and in some cases replace traditional model based design \napproaches, and thus represents a significant design element of a \nsoftware architecture. Such model driven approaches often also refer to\n\ndomain specific languages (DSL)\n.\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).\n\n\nMeta-model, model, and all that\n\n\nThe meta modeling toolsets utilized on this site typically allow to define\n\n(1) a meta model\n, which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a \ndata base layout\n.\nIt also can be compared to \nglossary\n for a given domain.\nUsing the meta model \n(2) model data\n can be defined by a user.\nThis model data represents the concrete \ndata structures for a given domain\n.\n\n(3) Validation\n: importantly, the meta model definition allows to validate\nand check concrete models. Finally, \n(4) code generators and\nmodel transformations\n represent primary end user tools to allow mass\nproduction based on a \nsingle source\n of information (the model).\n\n\nReal value for a project\n\n\nNotably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.\n\n\nThe \nreal value\n in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the \nmodel data\n itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.\n\n\nKeeping this in mind, one should be able to parse and\nunderstand the model data in, say, 10 years. Also think about what happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.\n\n\nMoreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#motivation",
            "text": "The problem to be solved is two-fold: avoid problems with communication  and  consistency .\nA  common language  will be defined to ease  communication  within and\nbetween teams. A  single source  of information implies  consistency ,\nand in turn, prevents misunderstandings.   A very good introduction to domain modeling is (Tomassetti, 2017) .",
            "title": "Motivation"
        },
        {
            "location": "/motivation/#mdsd-and-dsls",
            "text": "Model driven software development (MDSD)  allows\nintroducing a supplementary layer of\nabstraction above the code: This additional complexity can be employed to\ncomplement, and in some cases replace traditional model based design \napproaches, and thus represents a significant design element of a \nsoftware architecture. Such model driven approaches often also refer to domain specific languages (DSL) .\nThese languages make the design easy to communicate (defined language at\ndesign level) and at the same time the design itself constitutes of actual\nsoftware artefacts, since code is directly generated from it (single\nsource of information).",
            "title": "MDSD and DSLs"
        },
        {
            "location": "/motivation/#meta-model-model-and-all-that",
            "text": "The meta modeling toolsets utilized on this site typically allow to define (1) a meta model , which defines what is modeled, e.g.,\nthe basic layout of a data structure in terms of structures which have\nattributes. This meta model can be compared to a  data base layout .\nIt also can be compared to  glossary  for a given domain.\nUsing the meta model  (2) model data  can be defined by a user.\nThis model data represents the concrete  data structures for a given domain . (3) Validation : importantly, the meta model definition allows to validate\nand check concrete models. Finally,  (4) code generators and\nmodel transformations  represent primary end user tools to allow mass\nproduction based on a  single source  of information (the model).",
            "title": "Meta-model, model, and all that"
        },
        {
            "location": "/motivation/#real-value-for-a-project",
            "text": "Notably, if a model represents a real abstraction of a software\naspect - something people talk about and which hides important\ndetails - we get a big impact in productivity. From the one and\nsingle source of specification (the model data) we can extract\ndocumentation, plan and archive changes (in the models) and at\nthe same time guarantee the consistency of model and multiple code artefacts.  The  real value  in terms of working hours is not the meta model, the code\ngenerator or the editor of a model, but the  model data  itself. The\nrest of the employed toolset and definitions (e.g. the meta model) further\nincrease this value, by allowing to validate, transform or\nevaluate the model data.  Keeping this in mind, one should be able to parse and\nunderstand the model data in, say, 10 years. Also think about what happens if\nmultiple users create conflicts in model files. One should be able to repair\nsuch situations. This is easier if the model stored on disk resembles the\nmodel entered by the user, than if an alternative representation is used\nwith, e.g., binary data representations or machine generated IDs which are\ndifficult to understand. Such a simple representation on disk also allows to\neasily analyze a model with a traditional text search tool (grep) and to\nmake quick modifications to the model with a simple editor.  Moreover, the interoperability of employed toolsets is of crucial importancy:\nthe ability to define inter-model relations eases large scale model\ndriven approaches and the IDE integration increases end user acceptance.",
            "title": "Real value for a project"
        },
        {
            "location": "/basics/",
            "text": "Basics of meta modeling for domain models\n\n\nIn this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.\n\n\nAll aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.\n\n\nIntroductory example\n\n\nAn example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.\n\n\nA meta model may, thus, be sketched as follows:\n\n\n\n\nA program (domain model) may look as follows:\n\n\n\n\nOverview: aspects of meta modeling\n\n\nA summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset\n\nXtext\n\nand \nTextX\n.\n\n\n\n\nWhich \ndomain objects\n exist (\nglossary\n)?\n\n\nHow are objects identified (\nnamed\n)?\n\n\nWhich \nattributes\n do objects have?\n\n\nWhat objects are \ncomposed\n of other objects?\n\n\nWhat objects \naggregate\n other objects?\n\n\nHow do objects \nreference\n each other (including context effects/\nscoping\n)?\n\n\nHow can I \nspecialize\n objects?\n\n\nHow can I \nconnect\n objects?\n\n\nModularization\n: How can an object reference another object from another model\n    (form the same meta model or a different one)?\n\n\nInteroperability\n: How can an object reference something from outside\n    the toolset scope (inter-tool operability)?\n\n\nValidation\n: How can custom rules be checked automatically?\n\n\n\n\nDomain objects: identification and attributes\n\n\nDomain objects represent a central part of a \nglossary\n. Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.\n\n\nDomain objects\n can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have \nattributes\n, some of them optional. These attributes\nmay have a \nscalar\n value or represent a \nlist\n of entries. The value of the\nattributes can be specified to represent some \nbasic type\n (like a string or a\nnumber) or \nother domain\n objects.\n\n\nImportantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).\n\n\n\n\nNote: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.\n\n\nComposing objects\n\n\nDomain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:\n\n\n\n\nNote: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called \ncomposition\n and has clear \nownership\n semantics.\n\n\nReferences and Aggregation\n\n\nSome domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").\n\n\n\n\nNote: non-owning knowlegde of other objects is called \naggregation\n. Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).\n\n\nScoping\n\n\nScoping is relevant to \ndescribe what objects are identifiable\n when \nreferencing\nother objects\n. This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).\n\n\nAssume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":\n\n\n\n\nIn this case, we want that \nonly \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\"\n. This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.\n\n\nSpecialization (base classes/base rules)\n\n\nSometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).\n\n\n\n\nModularization\n\n\nThis happens when a model is splitted  in multiple submodels\n(e.g., different files).\n\n\n\n\nCombining meta models\n\n\nTo foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a \nmodularization of the meta model and, thus, the glossary\n.\n\n\nInteroperability with other toolsets or software components\n\n\nIn larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.\n\n\n\n\n Validation\n\n\nThe validation of a model consists of \nadditional checks on top of structural\nconsistency\n defined by the grammar and scoping.\n\n\n\n\nError in the structure\n    result in classical syntax errors (\"\nexpected\n 'XY' instead of 'AB'\").\n\n\nScoping, in turn, defines the possible references in some context and,\n    thus, yields errors of the catergory \"referenced element 'XY' \nnot found\n.\".\n\n\nThe \nvalidation\n described in this section is about additional\n    \nlogical checks\n, once the model is correctly parsed and all\n    references resolved. This additional checks typically have a\n    \nstrong relation to the domain\n.\n\n\n\n\nExample:\n Assume a model where \"testcases\" reference \"configurations of\nscenarios\" which have certain \"aspects\". On the other hand a \"testcase\" may\nneed certain aspects. If any of the \"Aspects\" required by a \"testcase\" is not\navailabe in the referenced \"configuration\", a logical error is reported\n(validation error).\n\n\nRationale\n for choosing a validation over a scoping solution in this case:\nWhen modeling a situation where a \"configuration\" is chosen by a \"testcase\"\nwithout providing the correct \"aspects\", one would not like to get a\n\"configuration not found\", which would result if only \"configurations\" with matching\n\"aspects\" are defined in the \nscope\n of a \"testcase\". In contrast, the\n\nvalidation\n will allow all \"configurations\" of the selected \"scenario\" of\na \"testcase\" to be visible, but some of them will produce a\n\nmeaningful domain error\n, such as\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\".\n\n\nThe structure defined in the meta model is shown as follows:\n\n\n\n\nA model with validation error (\n\"configuration 'config_B' does not provide the aspect 'aspect_X' required\nby testcase 'test_T1'\"\n) is shown as follows:\n\n\nscenario\n \nscenario_001\n \n{\n\n    \nconfiguration\n \nconfig_A\n \nhas\n \n{\naspect_X\n}\n\n    \nconfiguration\n \nconfig_B\n \nhas\n \n{\naspect_Y\n}\n\n\n}\n\n\ntestcase\n \ntest_T1\n \n{\n\n    \nuse\n \nscenario_001\n \nwith\n \nconfig_B\n\n    \nand\n \nneeds\n \n{\naspect_X\n}\n\n\n}\n\n\n\n\n\n\n\n\nA model without validation error is shown as follows:\n\n\nscenario\n \nscenario_001\n \n{\n\n    \nconfiguration\n \nconfig_A\n \nhas\n \n{\naspect_X\n}\n\n    \nconfiguration\n \nconfig_B\n \nhas\n \n{\naspect_Y\n,\n \naspect_X\n}\n\n\n}\n\n\ntestcase\n \ntest_T1\n \n{\n\n    \nuse\n \nscenario_001\n \nwith\n \nconfig_B\n\n    \nand\n \nneeds\n \n{\naspect_X\n}\n\n\n}",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#basics-of-meta-modeling-for-domain-models",
            "text": "In this section we describe typical meta modeling tasks.\nMeta modeling is the creation of a meta model.\nThis defines what can be modeled in a model for that given meta model.  All aspects identified here can be found in a tutorial style\nin corresponding sections for TextX and Xtext of this documentation.",
            "title": "Basics of meta modeling for domain models"
        },
        {
            "location": "/basics/#introductory-example",
            "text": "An example: A meta model for a programming language defines that, e.g.,\nvariables can be defined. The model, in turn, is a concrete programm\nwith many variable definitions.  A meta model may, thus, be sketched as follows:   A program (domain model) may look as follows:",
            "title": "Introductory example"
        },
        {
            "location": "/basics/#overview-aspects-of-meta-modeling",
            "text": "A summary of different aspects to be specified by the meta model is given\nas follows. This list is inspired by the grammar based toolset Xtext \nand  TextX .   Which  domain objects  exist ( glossary )?  How are objects identified ( named )?  Which  attributes  do objects have?  What objects are  composed  of other objects?  What objects  aggregate  other objects?  How do objects  reference  each other (including context effects/ scoping )?  How can I  specialize  objects?  How can I  connect  objects?  Modularization : How can an object reference another object from another model\n    (form the same meta model or a different one)?  Interoperability : How can an object reference something from outside\n    the toolset scope (inter-tool operability)?  Validation : How can custom rules be checked automatically?",
            "title": "Overview: aspects of meta modeling"
        },
        {
            "location": "/basics/#domain-objects-identification-and-attributes",
            "text": "Domain objects represent a central part of a  glossary . Thus,\ndefining such objects is a central part of any software specification\nand must be using through its design.  Domain objects  can represent things, like \"Customers\", \"Computers\",\n\"State machines\". In our context they can also represent activities\nand relationships,  like \"owns\" (a customers owns a computer) or\n\"runs\" (a computer runs a state machine).\nDomain objects may have  attributes , some of them optional. These attributes\nmay have a  scalar  value or represent a  list  of entries. The value of the\nattributes can be specified to represent some  basic type  (like a string or a\nnumber) or  other domain  objects.  Importantly, some domain objects need to be identified by a name (like a\n\"Customer\"), while other objects do not (like the \"Birthday\" in our\nexample below).   Note: Domain objects in the meta model represent a blueprint or a class of a\nconcrete instances of such objects in a concrete model.",
            "title": "Domain objects: identification and attributes"
        },
        {
            "location": "/basics/#composing-objects",
            "text": "Domain objects may be composed of other domain objects. Such a relationship\ncan be described by an attribute with a domain object type (like in the last\nsection). An alternative representation is illustrated as follows, but\ndescribes exactly the same thing:   Note: in this example, a Customer is composed of a Birthday object.\nThe Birthday object cannot exist without the Customer. This relationship\nis called  composition  and has clear  ownership  semantics.",
            "title": "Composing objects"
        },
        {
            "location": "/basics/#references-and-aggregation",
            "text": "Some domain objects need to reference identifiable objects without\nhaving their ownership. This happens, e.g.,\nwhen describing domain object relationships within the model (e.g. a\nCustomer owns a Computer; relationship \"own\"). Such relationships themselves\ncan own additional attributes (e.g. \"owns since date\").   Note: non-owning knowlegde of other objects is called  aggregation . Simple\nrelationships can be presented by a simple link (without attributes and without\nown rule/class definition).",
            "title": "References and Aggregation"
        },
        {
            "location": "/basics/#scoping",
            "text": "Scoping is relevant to  describe what objects are identifiable  when  referencing\nother objects . This is especially of importance, when some default visibility\nis not valid (most default scoping mechanisms allow all identifiable objects to be\nreferenced globally).  Assume the following meta model snippet, where a \"Scenario\" is composed of\n\"Configurations\" and a \"Testcase\" references \"Scenarios\" and \"Configurations\":   In this case, we want that  only \"Configurations\" of the \"Scenario\"\nreferenced by a \"Testcase\" are visible to the \"Testcase\" . This\nrestriction is context specific (to the context of the \"Testcase\" described\nby the referenced \"Scenario\"). Scoping mechanisms allow to define this scope.",
            "title": "Scoping"
        },
        {
            "location": "/basics/#specialization-base-classesbase-rules",
            "text": "Sometimes it happens that some domain object is too generic and needs to\nbe specialized. This may happen when the language evolves.\nDuring the initial design commonalities are identified which lead to\nthe same pattern (base class and specialization).",
            "title": "Specialization (base classes/base rules)"
        },
        {
            "location": "/basics/#modularization",
            "text": "This happens when a model is splitted  in multiple submodels\n(e.g., different files).",
            "title": "Modularization"
        },
        {
            "location": "/basics/#combining-meta-models",
            "text": "To foster modularization, meta models can be splitted and still allow to\nreference domain objects of one meta model from the other meta model. In our last example\nwe could define a meta model for \"Testcases\" and one meta model for\n\"Scenarios\". This feature is more demanding to the underlying technology but\nallows a  modularization of the meta model and, thus, the glossary .",
            "title": "Combining meta models"
        },
        {
            "location": "/basics/#interoperability-with-other-toolsets-or-software-components",
            "text": "In larger projects external databases or models may need to be referenced.\nSuch external sources of information may be, e.g., am existing database of\nrequirements, some JSON or XML file or similar things. Interoperability with\nthese sources of information allow to link the model to that source.",
            "title": "Interoperability with other toolsets or software components"
        },
        {
            "location": "/xtext_eclipse/",
            "text": "Xtext and Eclipse\n\n\nXtext is integrated in Eclispe.\nTo run this tutorial (using Xtext) you need to install Eclipse with the \nappropriate plugins.\n\n\nNote: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually \n(itemis update site)\n,\nelse it will be downloaded for every Xtext project you create.\n\n\nDownload and install\n\n\nDownload the package\n\n\"Eclipse Modeling\"\n.\nUnpack the archive to make eclipse available.\n\n\nroot@xtext:~/Download# ls\neclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse \n&\n\n\n\n\n\n\nTo complete the installation you need \"Install New Software\" from the\n\"Help\" menu entry. \n\n\n\n\nEnter the URL of the itemis update site (see above)\n    in the field \"work with\" and press enter. \n\n\nThen select \"Xtext\" and \"Xtext Antlr\" and install the selected software.",
            "title": "Eclipse"
        },
        {
            "location": "/xtext_eclipse/#xtext-and-eclipse",
            "text": "Xtext is integrated in Eclispe.\nTo run this tutorial (using Xtext) you need to install Eclipse with the \nappropriate plugins.  Note: The parser \"Antlr\" is not distributed with eclipse. You need to install\nit manually  (itemis update site) ,\nelse it will be downloaded for every Xtext project you create.",
            "title": "Xtext and Eclipse"
        },
        {
            "location": "/xtext_eclipse/#download-and-install",
            "text": "Download the package \"Eclipse Modeling\" .\nUnpack the archive to make eclipse available.  root@xtext:~/Download# ls\neclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# tar xzf eclipse-modeling-xxx-linux-gtk-x86_64.tar.gz\nroot@xtext:~/Download# mv eclipse /opt/\nroot@xtext:~/Download# /opt/eclipse/eclipse  &   To complete the installation you need \"Install New Software\" from the\n\"Help\" menu entry.    Enter the URL of the itemis update site (see above)\n    in the field \"work with\" and press enter.   Then select \"Xtext\" and \"Xtext Antlr\" and install the selected software.",
            "title": "Download and install"
        },
        {
            "location": "/xtext_project_setup/",
            "text": "Xtext Project Setup\n\n\nGoal\n\n\nIn this section you will learn\n\n\n\n\nHow to create a new XText Project.\n\n\nHow to run you toolchain (edtior and parser).\n\n\nWhat Project structures are created.\n\n\nRun a unittest testing the parser.\n\n\nOptional: How to start a build of your toolchain with maven at the \n   commmandline\n\n\n\n\nStep 1: Create a new Xtext Project\n\n\nFollow section \"Create A New Xtext Project\"\nin \n(Xtext 15 Minutes Tutorial)\n.\n\n\nIn addition to the information from the tutorial we\nsuggest the following details for the other examples\ndiscussed on this site:\n\n\n\nThe result are a set of projects: we are mainly interrested in the\nfirst project, which contains the grammar.\n\n\nStep 2: Exploring the new domain model language\n\n\nThe example grammar (automatically created after project\ninitialization) defines a \"Model\" consisting of \n\"Greetings\" is shown in the following. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details below).\n\n\ngrammar\n \norg.example.domainmodel.Domainmodel\n \nwith\n\n\n                                  \norg.eclipse.xtext.common.Terminals\n\n\ngenerate\n \ndomainmodel\n \n\"http\n:\n//www.example.org/domainmodel/Domainmodel\"\n\n\n\nModel\n:\n\n\n    \ngreetings\n+=\nGreeting\n*\n;\n\n\n\nGreeting\n:\n\n\n    \n'Hello'\n \nname\n=\nID\n \n'!'\n;\n\n\n\n\n\n\n\n\nNotes:\n\n\n\n\n\"+=\" denotes the owner relationship of one Model containing many Greetings \n    (\ncomposition\n).\n\n\n\"name=ID\" defines an attribute \"name\" of the Rule \"Greeting\" (allowing to \n    define model elements of the type \"Greeting\"; \nattributes\n of \n    \nmodel elements\n).\n\n\nThe attribute name has a special meaning by default, to denote the \n    identifier of the Rule (\nidentification of model elements\n).\n\n\nID is a terminal (like INT, STRING, etc.; see grammar, and click \"F3\" on\n      \"org.eclipse.xtext.common.Terminals\" to see definition).\n   \"name=ID\" means that the attribute \"name\" is parsed as \"ID\" (which in turn\n   is - more or less - an alphanumerical word staring with no number)\n\n\n\n\nNote on version control\n\n\nWhen using git or svn make sure not to commit any generated code\n(e.g. everything under src-gen and xtend-gen). Use, e.g., a .gitignore file\nlike the following:\n\n\ntarget\nsrc-gen\nxtend-gen\n.settings\n.metadata\nbin\ngenerated\n\n\n\n\n\nStep 3: Compile and Run the Project\n\n\n Compile and Run the Project: Without \nmodifing the grammar (or anything else), follow the steps in\nsection \"Generate Language Artifacts\" in \n\n(Xtext 15 Minutes Tutorial)\n.\n\n\nAfter this, you can use explore the editor and enter a model according to \nthe example meta model grammar provided by the Xtext project setup. \n\n\nNow you can play with your new language (type CTRL-Space to get auto\ncompletion). Enter the following example:\n\n\nHello Pierre!\n\n\nHello Tim!\n\n\nHello Markus!\n\n\n\n\n\n\nStep 5: Add Unittests\n\n\nIn the test project you can add a unitests. Locate the single file in\nthe src folder. This file contains a unittest. Uncomment the test code and\nrun the test. \n\n\nNote: You need to generate the xtext artefact before (see above).\n\n\nOptional step 5: Build meta model using maven\n\n\nWhen maven is selected as build tool, you can also use maven (instead of\neclipse) to build your project on the command line: Go to the \"parent\" \nproject and run \"mvn package\".\n\n\nMaven will download all required packages in \"~/.m2\" (locally) and then build \nyour subprojects. The output is located in the folder \"target\" of each \nsubproject.\n\n\nSee also: \n(Maven)\n.\n\n\nHint: When using the Xtext version shipped with the Photon eclipse version \nin September 2018, I got an error reported by maven which I solved by inserting \na small snippted to correct\na version (everythiong between <dependencies> and </dependencies>,\nsee \nhttps://github.com/eclipse/xtext/issues/1231\n.\n\n\n<plugin>\n\n    \n<groupId>\norg.eclipse.xtend\n</groupId>\n\n    \n<artifactId>\nxtend-maven-plugin\n</artifactId>\n\n    \n<version>\n${\nxtextVersion\n}\n</version>\n\n    \n<dependencies>\n\n        \n<dependency>\n\n            \n<groupId>\norg.eclipse.platform\n</groupId>\n\n            \n<artifactId>\norg.eclipse.equinox.common\n</artifactId>\n\n            \n<version>\n3.10.0\n</version>\n\n        \n</dependency>\n\n    \n</dependencies>\n\n...",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#xtext-project-setup",
            "text": "",
            "title": "Xtext Project Setup"
        },
        {
            "location": "/xtext_project_setup/#goal",
            "text": "In this section you will learn   How to create a new XText Project.  How to run you toolchain (edtior and parser).  What Project structures are created.  Run a unittest testing the parser.  Optional: How to start a build of your toolchain with maven at the \n   commmandline",
            "title": "Goal"
        },
        {
            "location": "/xtext_project_setup/#step-1-create-a-new-xtext-project",
            "text": "Follow section \"Create A New Xtext Project\"\nin  (Xtext 15 Minutes Tutorial) .  In addition to the information from the tutorial we\nsuggest the following details for the other examples\ndiscussed on this site:  The result are a set of projects: we are mainly interrested in the\nfirst project, which contains the grammar.",
            "title": "Step 1: Create a new Xtext Project"
        },
        {
            "location": "/xtext_project_setup/#step-2-exploring-the-new-domain-model-language",
            "text": "The example grammar (automatically created after project\ninitialization) defines a \"Model\" consisting of \n\"Greetings\" is shown in the following. A \"Model\" contains \"Greetings\".\nEvery \"Greeting\" consists of the Text 'Hello' and a name followed by '!'\n(details below).  grammar   org.example.domainmodel.Domainmodel   with                                     org.eclipse.xtext.common.Terminals  generate   domainmodel   \"http : //www.example.org/domainmodel/Domainmodel\"  Model :       greetings += Greeting * ;  Greeting :       'Hello'   name = ID   '!' ;    Notes:   \"+=\" denotes the owner relationship of one Model containing many Greetings \n    ( composition ).  \"name=ID\" defines an attribute \"name\" of the Rule \"Greeting\" (allowing to \n    define model elements of the type \"Greeting\";  attributes  of \n     model elements ).  The attribute name has a special meaning by default, to denote the \n    identifier of the Rule ( identification of model elements ).  ID is a terminal (like INT, STRING, etc.; see grammar, and click \"F3\" on\n      \"org.eclipse.xtext.common.Terminals\" to see definition).\n   \"name=ID\" means that the attribute \"name\" is parsed as \"ID\" (which in turn\n   is - more or less - an alphanumerical word staring with no number)",
            "title": "Step 2: Exploring the new domain model language"
        },
        {
            "location": "/xtext_project_setup/#note-on-version-control",
            "text": "When using git or svn make sure not to commit any generated code\n(e.g. everything under src-gen and xtend-gen). Use, e.g., a .gitignore file\nlike the following:  target\nsrc-gen\nxtend-gen\n.settings\n.metadata\nbin\ngenerated",
            "title": "Note on version control"
        },
        {
            "location": "/xtext_project_setup/#step-3-compile-and-run-the-project",
            "text": "Compile and Run the Project: Without \nmodifing the grammar (or anything else), follow the steps in\nsection \"Generate Language Artifacts\" in  (Xtext 15 Minutes Tutorial) .  After this, you can use explore the editor and enter a model according to \nthe example meta model grammar provided by the Xtext project setup.   Now you can play with your new language (type CTRL-Space to get auto\ncompletion). Enter the following example:  Hello Pierre!  Hello Tim!  Hello Markus!",
            "title": "Step 3: Compile and Run the Project"
        },
        {
            "location": "/xtext_project_setup/#step-5-add-unittests",
            "text": "In the test project you can add a unitests. Locate the single file in\nthe src folder. This file contains a unittest. Uncomment the test code and\nrun the test.   Note: You need to generate the xtext artefact before (see above).",
            "title": "Step 5: Add Unittests"
        },
        {
            "location": "/xtext_project_setup/#optional-step-5-build-meta-model-using-maven",
            "text": "When maven is selected as build tool, you can also use maven (instead of\neclipse) to build your project on the command line: Go to the \"parent\" \nproject and run \"mvn package\".  Maven will download all required packages in \"~/.m2\" (locally) and then build \nyour subprojects. The output is located in the folder \"target\" of each \nsubproject.  See also:  (Maven) .  Hint: When using the Xtext version shipped with the Photon eclipse version \nin September 2018, I got an error reported by maven which I solved by inserting \na small snippted to correct\na version (everythiong between <dependencies> and </dependencies>,\nsee  https://github.com/eclipse/xtext/issues/1231 .  <plugin> \n     <groupId> org.eclipse.xtend </groupId> \n     <artifactId> xtend-maven-plugin </artifactId> \n     <version> ${ xtextVersion } </version> \n     <dependencies> \n         <dependency> \n             <groupId> org.eclipse.platform </groupId> \n             <artifactId> org.eclipse.equinox.common </artifactId> \n             <version> 3.10.0 </version> \n         </dependency> \n     </dependencies> \n...",
            "title": "Optional step 5: Build meta model using maven"
        },
        {
            "location": "/xtext_a_first_grammar/",
            "text": "A First Grammar\n\n\nHere we highlight some information when walking through\n\n(Xtext 15 Minutes Tutorial)\n.\n\n\nGoal\n\n\nIn this section you will learn\n\n\n\n\nHow to model hierarchical data structures (things containing things).\n\n\nHow to model references (things referencing things).\n\n\nHow to identify model elements (by name). \n\n\nHow to model specialization.\n\n\n\n\nNote: How to identify model elements in other hierarchical elements\n(e.g. packages) will be handled later.\n\n\nStep 1: Create and run an Xtext project\n\n\nTake your time for this tutorial now and continue reading afterwards.\nYou may \nstop before \"Second Iteration\"\n where \"packages\"\nare added to the model.\n\n\nStep 2: Questions\n\n\nCheck if you understood thw following points:\n\n\n\n\nWhat is the role of the \nstart rule\n of a grammar in a meta model?\n\n\nWhat is the meaning of \"Type: DataType | Entity;\" in terms of inheritance? \n    Explore the generated Java Interfaces for the classes Type, DataType, \n    Entity in  src-gen/org/example/domainmodel/domainmodel in your main \n    project.\n\n\nHow do you typically add keywords to your language (like \"entity\")?\n\n\nWhat is the difference between \"x=Rule1\" and \"x=[Rule1]\"?\n\n\nHow can you model the following?\n\n\n\"a \nnamed\n \nUniversity\n aggregates \nnamed\n \nStudents\n\".\n\n\n\"a \nHouse\n is composed of \nRooms\n\" \n    \n Composition.\n\n\n\n\n\n\nExplain the role of \"?\" in the following examples: \n\n\n(x=INT)?\n\n\nenabled?='enabled'\n\n\n\n\n\n\n\n\nNote:\n\n\n\n\nOptional attributes can be defined using \"?\". Note: some types, like \n   references, are null if not set. Others have default values (like an empty\n   String for STRING, \"0\" for INT or the first enum value defined for enums).\n\n\nRules without attributes does not yield an object \n   (e.g.: \"Thing: INT\"). You can force the object creation with the\n   following syntax using curly brackets: \"Thing: {Thing} INT\".\n\n\n\n\nStep 3: More examples\n\n\nCan you interpret the following snippet:\n\n\n// ...\n\n\nModel\n:\n \ncustomers\n+=\nCustomer\n*\n \ncomputers\n+=\nComputer\n*\n \nowns\n+=\nOwns\n*\n;\n\n\nComputer\n:\n \n'computer'\n \nname\n=\nID\n;\n\n\nCustomer\n:\n \n'customer'\n \nname\n=\nID\n;\n\n\nOwn\n:\n \n'the'\n \ncomputer\n=\n[\nComputer\n]\n \n\n\n     \n'is'\n \n'owned'\n \n'by'\n \ncustomer\n=\n[\nCustomer\n]\n \n\n\n     \n'since'\n \ndate\n=\nSTRING\n;\n\n\n\n\n\n\nWhat changes, when we define the 'Model' differently:\n\n\nModel\n:\n \n(\ncustomers\n+=\nCustomer\n \ncomputers\n+=\nComputer\n \nowns\n+=\nOwns\n)*\n;\n\n\n\n\n\n\nStep 4: Editor\n\n\nIn addition to the text editor,\nyou can also edit the model with a \ntree editor\n:\nopen the file with \"Open With...\" - \"Sample Ecore Model Editor\".\n\n\nWhen editing the model graph, the model text is changed accordingly: \nsee the Xtext \n\"Formatter\"\n \nin the online help of Xtext (in the internet or within eclipse): \n\n\nStep 5: Visualize the meta model\n\n\nThe \necore model\n  deduced from the grammar can be \nvisualized\n:\nsee \n(Mooij et al, 2017a)\n,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).\n\n\nMoreover a \nsyntax tree\n can be rendered from the grammar:\nsee \n(Mooij et al, 2017a)\n,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).\n\n\nOptional Step 6: Adapt you unittests\n\n\nAdapt your unittests.",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#a-first-grammar",
            "text": "Here we highlight some information when walking through (Xtext 15 Minutes Tutorial) .",
            "title": "A First Grammar"
        },
        {
            "location": "/xtext_a_first_grammar/#goal",
            "text": "In this section you will learn   How to model hierarchical data structures (things containing things).  How to model references (things referencing things).  How to identify model elements (by name).   How to model specialization.   Note: How to identify model elements in other hierarchical elements\n(e.g. packages) will be handled later.",
            "title": "Goal"
        },
        {
            "location": "/xtext_a_first_grammar/#step-1-create-and-run-an-xtext-project",
            "text": "Take your time for this tutorial now and continue reading afterwards.\nYou may  stop before \"Second Iteration\"  where \"packages\"\nare added to the model.",
            "title": "Step 1: Create and run an Xtext project"
        },
        {
            "location": "/xtext_a_first_grammar/#step-2-questions",
            "text": "Check if you understood thw following points:   What is the role of the  start rule  of a grammar in a meta model?  What is the meaning of \"Type: DataType | Entity;\" in terms of inheritance? \n    Explore the generated Java Interfaces for the classes Type, DataType, \n    Entity in  src-gen/org/example/domainmodel/domainmodel in your main \n    project.  How do you typically add keywords to your language (like \"entity\")?  What is the difference between \"x=Rule1\" and \"x=[Rule1]\"?  How can you model the following?  \"a  named   University  aggregates  named   Students \".  \"a  House  is composed of  Rooms \" \n      Composition.    Explain the role of \"?\" in the following examples:   (x=INT)?  enabled?='enabled'     Note:   Optional attributes can be defined using \"?\". Note: some types, like \n   references, are null if not set. Others have default values (like an empty\n   String for STRING, \"0\" for INT or the first enum value defined for enums).  Rules without attributes does not yield an object \n   (e.g.: \"Thing: INT\"). You can force the object creation with the\n   following syntax using curly brackets: \"Thing: {Thing} INT\".",
            "title": "Step 2: Questions"
        },
        {
            "location": "/xtext_a_first_grammar/#step-3-more-examples",
            "text": "Can you interpret the following snippet:  // ...  Model :   customers += Customer *   computers += Computer *   owns += Owns * ;  Computer :   'computer'   name = ID ;  Customer :   'customer'   name = ID ;  Own :   'the'   computer = [ Computer ]          'is'   'owned'   'by'   customer = [ Customer ]          'since'   date = STRING ;   What changes, when we define the 'Model' differently:  Model :   ( customers += Customer   computers += Computer   owns += Owns )* ;",
            "title": "Step 3: More examples"
        },
        {
            "location": "/xtext_a_first_grammar/#step-4-editor",
            "text": "In addition to the text editor,\nyou can also edit the model with a  tree editor :\nopen the file with \"Open With...\" - \"Sample Ecore Model Editor\".  When editing the model graph, the model text is changed accordingly: \nsee the Xtext  \"Formatter\"  \nin the online help of Xtext (in the internet or within eclipse):",
            "title": "Step 4: Editor"
        },
        {
            "location": "/xtext_a_first_grammar/#step-5-visualize-the-meta-model",
            "text": "The  ecore model   deduced from the grammar can be  visualized :\nsee  (Mooij et al, 2017a) ,\nsection \"Optional: Ecore diagram\" (\u201eInitialize Ecore Diagram ...\u201c).  Moreover a  syntax tree  can be rendered from the grammar:\nsee  (Mooij et al, 2017a) ,\nsection \"Optional: View Diagram of Xtext Grammar\"\n(Window/Show View/Other.../Xtext/Xtext Syntax Graph).",
            "title": "Step 5: Visualize the meta model"
        },
        {
            "location": "/xtext_a_first_grammar/#optional-step-6-adapt-you-unittests",
            "text": "Adapt your unittests.",
            "title": "Optional Step 6: Adapt you unittests"
        },
        {
            "location": "/xtext_code_generation_xtend/",
            "text": "Code Generation (with Xtend)\n\n\nXtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).\n\n\nHere we highlight some information when walking through\n\n(Xtext 15 Minutes Tutorial, Extended)\n, \nsection \"Writing a Code Generator With Xtend\".\n\n\nGoal of this section\n\n\n\n\nYou learn how to generate Artefacts in form of text files (e.g. source code).\n\n\nYou learn how to format the output and how to access model data.\n\n\nAfter some basic steps you may have a look at \n    \nxtext_xtend.md\n to learn more about the language xtend \n    employed for the artefact generator.\n\n\nFinally, you see how you can generate a C++-file based on the model. You\n   will see how you can start from an example code and iteratively replace\n   concrete code with model data.\n\n\n\n\nStep 1: Walkthough\n\n\nWhen reading \n(Xtext 15 Minutes Tutorial, Extended)\n, start with the\nfirst section \"Writing a Code Generator With Xtend\" (until \n\"Unit Testing the Language\"): \n\n\n\n\nLocate the file where the \nartifact generator\n is implemented \n    (DomainmodelGenerator.xtend).\n\n\n\"\ndoGenerate\n\" is the method called when generating artifacts from a model.\n\n\nIgnore the \"IQualifiedNameProvider\": You can just use \"obj.name\" in your \n    example (instead of obj.fullyQualifiedName) for the moment.\n\n\nXtend allows to use templates (indicated by multiline strings with\n    three single quotes): \n\n\nInside this templates you can place \ntext which \n  is directly inserted\n in the output. \n\n\nSpecial commands\n like \"IF\" or \"FOR\" can be used if placed between \n  \"\u00ab\" and \"\u00bb\" \n  (\"\u00ab\" and \"\u00bb\" can be entered using CTRL-< and CTRL-> within eclipse).\n\n\nIs is also possible to \ninsert local variable contensts\n (typically model \n  data, e.g. '''the name of the entitiy is \u00abentity_var.name\u00bb''').\n\n\nTabs are inserted in an intelligent way, such that \nindentation\n associated\n  with generator logic (e.g., after an \"\u00abIF\u00bb\") are not inserted into the\n  output (such indentation is visually highlighted in the editor).\n\n\n\n\n\n\nOptional model elements\n which are represented as a class are null, when\n    not used. Caution: Other elements, such as enums, INT, and STRING have\n    default values.\n\n\nThe example also shows that a \nmodularization\n is possible (see how \n    code for \"Features\" is inserted).\n\n\nMany aspects may look scary at first sight, but are extremely valuable \n    for teh given task of textual artifact generation: \n    See \nxtext_xtend.md\n.\n\n\n\n\nNote:\n\n\n\n\n\n\nThis following example als illustrates how to get the\n    root of the model (val model=...). This object can be passsed to\n    a function generating some text from it.\n\n\nval\n \nmodel\n \n=\n \nresource\n.\ncontents\n.\nget\n(\n0\n)\n \nas\n \nDomainmodel\n\n\n\n\n\n\n\n\n\n\nIt also shows how to cast an object: \u201eobj as Type\u201c.\n\n\n\n\n\n\nStep 2: Question\n\n\nWhat is the following code doing? See \nxtext_xtend.md\n.\n\n\noverride\n \nvoid\n \ndoGenerate\n(\nResource\n \nresource\n,\n \nIFileSystemAccess2\n \nfsa\n,\n \nIGeneratorContext\n \ncontext\n)\n \n{\n\n    \nfsa\n.\ngenerateFile\n(\n'greetings.txt'\n,\n \n'People to greet: '\n \n+\n \n        \nresource\n.\nallContents\n\n            \n.\nfilter\n(\nEntity\n)\n\n            \n.\nmap\n[\nname\n]\n\n            \n.\njoin\n(\n', '\n))\n\n\n}\n\n\n\n\n\n\nStep 3: Next step: Extended example\n\n\nTry to generate a C-code snippet:\n\n\n#ifndef __MYSTRUCT_H_\n\n\n#define __MYSTRUCT_H_\n\n\n#include\n \n<cstdint>\n\n\n\nstruct\n \nMyStruct\n \n{\n\n    \nfloat\n \nattribute1\n;\n\n    \nint32_t\n \nattribute2\n;\n\n\n};\n\n\n\n#endif\n\n\n\n\n\n\nWhen starting a new generator snippet, it can help to copy-paste\nthe code to be generate as an example into your code:\n\n\ndef\n \ngenerateCppCode\n(\nEntity\n \ne\n)\n \n{\n\n    \n'''\n\n\n    #ifndef __MYSTRUCT_H_\n\n\n    #define __MYSTRUCT_H_\n\n\n    #include <cstdint>\n\n\n\n    struct MyStruct {\n\n\n        float attribute1;\n\n\n        int32_t attribute2;\n\n\n    };\n\n\n\n    #endif\n\n\n    '''\n\n\n}\n\n\n\n\n\n\nThen start replacing your example code with model information:  \n\n\ndef\n \ngenerateCppCode\n(\nEntity\n \ne\n)\n \n{\n\n    \n'''\n\n\n    #ifndef __MYSTRUCT_H_ // TODO\n\n\n    #define __MYSTRUCT_H_ // TODO\n\n\n    #include <cstdint>\n\n\n\n    struct \u00ab\ne\n.\nname\n\u00bb {\n\n\n    \u00ab\nFOR\n \nf\n \n:\n \ne\n.\nfeatures\n\u00bb\n\n\n        TODO \u00ab\nf\n.\nname\n\u00bb;\n\n\n    \u00ab\nENDFOR\n\u00bb\n\n\n    };\n\n\n\n    #endif\n\n\n    '''\n\n\n}\n\n\n\n\n\n\n... and integrate\nyour new functionality in your \"doGenerate\" method:\n\n\n// integrate the new generator\n\n\nfor\n \n(\ne\n \n:\n \nresource\n.\nallContents\n.\nfilter\n(\nEntity\n).\ntoIterable\n)\n \n{\n\n    \nfsa\n.\ngenerateFile\n(\ne\n.\nname\n+\n'.h'\n,\n \ngenerateCppCode\n(\ne\n))\n\n\n}\n\n\n\n\n\n\nOptional Step 4: Create a command line version of your \"compiler\"\n\n\nSee \nxtext_deploy_command_line.md\n.",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#code-generation-with-xtend",
            "text": "Xtend is highly optimized to be used\nfor code generation. It has a optimzed template engine (e.g., with\nautomatic indentation support) and\nis fully integrated in the Eclipse IDE (auto completition\nfor model data).  Here we highlight some information when walking through (Xtext 15 Minutes Tutorial, Extended) , \nsection \"Writing a Code Generator With Xtend\".",
            "title": "Code Generation (with Xtend)"
        },
        {
            "location": "/xtext_code_generation_xtend/#goal-of-this-section",
            "text": "You learn how to generate Artefacts in form of text files (e.g. source code).  You learn how to format the output and how to access model data.  After some basic steps you may have a look at \n     xtext_xtend.md  to learn more about the language xtend \n    employed for the artefact generator.  Finally, you see how you can generate a C++-file based on the model. You\n   will see how you can start from an example code and iteratively replace\n   concrete code with model data.",
            "title": "Goal of this section"
        },
        {
            "location": "/xtext_code_generation_xtend/#step-1-walkthough",
            "text": "When reading  (Xtext 15 Minutes Tutorial, Extended) , start with the\nfirst section \"Writing a Code Generator With Xtend\" (until \n\"Unit Testing the Language\"):    Locate the file where the  artifact generator  is implemented \n    (DomainmodelGenerator.xtend).  \" doGenerate \" is the method called when generating artifacts from a model.  Ignore the \"IQualifiedNameProvider\": You can just use \"obj.name\" in your \n    example (instead of obj.fullyQualifiedName) for the moment.  Xtend allows to use templates (indicated by multiline strings with\n    three single quotes):   Inside this templates you can place  text which \n  is directly inserted  in the output.   Special commands  like \"IF\" or \"FOR\" can be used if placed between \n  \"\u00ab\" and \"\u00bb\" \n  (\"\u00ab\" and \"\u00bb\" can be entered using CTRL-< and CTRL-> within eclipse).  Is is also possible to  insert local variable contensts  (typically model \n  data, e.g. '''the name of the entitiy is \u00abentity_var.name\u00bb''').  Tabs are inserted in an intelligent way, such that  indentation  associated\n  with generator logic (e.g., after an \"\u00abIF\u00bb\") are not inserted into the\n  output (such indentation is visually highlighted in the editor).    Optional model elements  which are represented as a class are null, when\n    not used. Caution: Other elements, such as enums, INT, and STRING have\n    default values.  The example also shows that a  modularization  is possible (see how \n    code for \"Features\" is inserted).  Many aspects may look scary at first sight, but are extremely valuable \n    for teh given task of textual artifact generation: \n    See  xtext_xtend.md .   Note:    This following example als illustrates how to get the\n    root of the model (val model=...). This object can be passsed to\n    a function generating some text from it.  val   model   =   resource . contents . get ( 0 )   as   Domainmodel     It also shows how to cast an object: \u201eobj as Type\u201c.",
            "title": "Step 1: Walkthough"
        },
        {
            "location": "/xtext_code_generation_xtend/#step-2-question",
            "text": "What is the following code doing? See  xtext_xtend.md .  override   void   doGenerate ( Resource   resource ,   IFileSystemAccess2   fsa ,   IGeneratorContext   context )   { \n     fsa . generateFile ( 'greetings.txt' ,   'People to greet: '   +  \n         resource . allContents \n             . filter ( Entity ) \n             . map [ name ] \n             . join ( ', ' ))  }",
            "title": "Step 2: Question"
        },
        {
            "location": "/xtext_code_generation_xtend/#step-3-next-step-extended-example",
            "text": "Try to generate a C-code snippet:  #ifndef __MYSTRUCT_H_  #define __MYSTRUCT_H_  #include   <cstdint>  struct   MyStruct   { \n     float   attribute1 ; \n     int32_t   attribute2 ;  };  #endif   When starting a new generator snippet, it can help to copy-paste\nthe code to be generate as an example into your code:  def   generateCppCode ( Entity   e )   { \n     '''      #ifndef __MYSTRUCT_H_      #define __MYSTRUCT_H_      #include <cstdint>      struct MyStruct {          float attribute1;          int32_t attribute2;      };      #endif      '''  }   Then start replacing your example code with model information:    def   generateCppCode ( Entity   e )   { \n     '''      #ifndef __MYSTRUCT_H_ // TODO      #define __MYSTRUCT_H_ // TODO      #include <cstdint>      struct \u00ab e . name \u00bb {      \u00ab FOR   f   :   e . features \u00bb          TODO \u00ab f . name \u00bb;      \u00ab ENDFOR \u00bb      };      #endif      '''  }   ... and integrate\nyour new functionality in your \"doGenerate\" method:  // integrate the new generator  for   ( e   :   resource . allContents . filter ( Entity ). toIterable )   { \n     fsa . generateFile ( e . name + '.h' ,   generateCppCode ( e ))  }",
            "title": "Step 3: Next step: Extended example"
        },
        {
            "location": "/xtext_code_generation_xtend/#optional-step-4-create-a-command-line-version-of-your-compiler",
            "text": "See  xtext_deploy_command_line.md .",
            "title": "Optional Step 4: Create a command line version of your \"compiler\""
        },
        {
            "location": "/xtext_model_validation/",
            "text": "Model \n Validation\n\n\nA model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see \n(Mooij et al, 2017a)\n.\n\n\n(Rentz-Reichert, 2017)\n\nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.\n\n\nA good introduction can be found here:\n\n(Xtext 15 Minutes Tutorial, Extended)\n, in the section \n\"Creating Custom Validation Rules\".\n\n\nValidation Example\n\n\nOpen the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:\n\n\npackage\n \nkurs\n.\nxtext\n.\ndataflow\n.\nvalidation\n\n\n\nimport\n \norg.eclipse.xtext.validation.Check\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.KComponent\n\n\nimport\n \nkurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage\n\n\n\nclass\n \nDataFlowDslValidator\n \nextends\n \nAbstractDataFlowDslValidator\n \n{\n\n\n    \npublic\n \nstatic\n \nval\n \nINVALID_NAME\n \n=\n \n'invalidName'\n\n\n    \n@Check\n\n    \ndef\n \ncheckGreetingStartsWithCapital\n(\nEntity\n \nobj\n)\n \n{\n\n        \nif\n \n(!\nCharacter\n.\nisUpperCase\n(\nobj\n.\nname\n.\ncharAt\n(\n0\n)))\n \n{\n\n            \nwarning\n(\n'Name should start with a capital'\n,\n \n                    \nDomainmodelPackage\n.\nLiterals\n.\nTYPE__NAME\n,\n\n                    \nINVALID_NAME\n)\n\n        \n}\n\n    \n}\n\n\n\n}\n\n\n\n\n\n\nTry your validator for your language in the Eclipse Runtime model editor.\n\n\n\nNotes:\n\n\n\n\nA validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.\n\n\nThe rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)\n\n\nThe rule above checks elements of type \"Entity\". \n     Errors/warning, if present, are attached to this model element.\n\n\nA rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.\n\n\nWhy did we use \"TYPE_NAME\" instead of ENTITY_NAME? (Hint: ENTITY_NAME does\n     not exist; How are Type and Entity related to each other?)",
            "title": "Model Validation"
        },
        {
            "location": "/xtext_model_validation/#model-validation",
            "text": "A model can be validated according certain validation rules.\nThese rules have to be define by the meta modeller\nin the meta model. Error and warning messages can be reported\nand attached to model elements or text location. These\nmessages are displayed in the Eclipse model text editor.\nMore Information, see  (Mooij et al, 2017a) .  (Rentz-Reichert, 2017) \nsuggested to put as little as possible semantics into\nthe grammar (e.g. \"+\" instead of \"*\") and to add this \nsemantics to the validation code. This often allows\nto generate more meaningful domain errors.  A good introduction can be found here: (Xtext 15 Minutes Tutorial, Extended) , in the section \n\"Creating Custom Validation Rules\".",
            "title": "Model "
        },
        {
            "location": "/xtext_model_validation/#validation-example",
            "text": "Open the *Validator.xtend\" file (automatically generated for\na new project), e.g., \n\"kurs.xtext.dataflow.validation.DataFlowDslValidator.xtend\".\nActivate the commented code and modify it:  package   kurs . xtext . dataflow . validation  import   org.eclipse.xtext.validation.Check  import   kurs.xtext.dataflow.dataFlowDsl.KComponent  import   kurs.xtext.dataflow.dataFlowDsl.DataFlowDslPackage  class   DataFlowDslValidator   extends   AbstractDataFlowDslValidator   { \n\n     public   static   val   INVALID_NAME   =   'invalidName' \n\n     @Check \n     def   checkGreetingStartsWithCapital ( Entity   obj )   { \n         if   (! Character . isUpperCase ( obj . name . charAt ( 0 )))   { \n             warning ( 'Name should start with a capital' ,  \n                     DomainmodelPackage . Literals . TYPE__NAME , \n                     INVALID_NAME ) \n         } \n     }  }   Try your validator for your language in the Eclipse Runtime model editor.  Notes:   A validation rule is marked as such with the annotation \"@Check\". \n     The argument is a model element of the type to be checked.  The rule is checked during typing in the editor \n     (@Check allows to control if a rule is checked during \n     typing, when saving, or upon explicit request\n     (see: org.eclipse.xtext.validation.CheckType; \n     press \"F3\" when having the cursor on @Check)  The rule above checks elements of type \"Entity\". \n     Errors/warning, if present, are attached to this model element.  A rule can generate \"errors\", \"warnings\" und \"infos\".\n     The ID (in our case \"INVALID_NAME\") allows a rule to \n     be identified later, e.g., when\n     implementing HotFixes for specific validation violations.  Why did we use \"TYPE_NAME\" instead of ENTITY_NAME? (Hint: ENTITY_NAME does\n     not exist; How are Type and Entity related to each other?)",
            "title": "Validation Example"
        },
        {
            "location": "/xtext_xtend/",
            "text": "Xtend: Selected Aspects\n\n\nIn addition to the features sketched in the\n\n\"code generation with Xtend\" section\n\nthis section provides some selected aspects we found useful for our work.\n\n\nExtension mechanism\n\n\nXtend has its name from the the fact that it allows to extend classes of\nthe language without using inheritance. There are different possibilities\nto achieve this task. One simple example of such an extended class \nis java.lang.String, which was extended by Xtend to provide \na method \"toFirstUpper\".\n\n\nA simple possibility to achieve such an extension is to define a locally\nvisible method \"\nf(\nTypeX x, \n...)\n\" (see \nXtend documentation\n).\nWith this, TypeX is extened by a method \nf(...)\n.\n\n\ndef\n \nprintNTimes\n(\nString\n \ns\n,\n \nint\n \nn\n)\n \n{\n\n    \nfor\n(\nvar\n \ni\n=\n0\n;\ni\n<\nn\n;\ni\n++)\n \nprintln\n(\ns\n)\n\n\n}\n\n\n\n...\n     \n    \n\"Hello\"\n.\nprintNTimes\n(\n3\n)\n\n\n...\n\n\n\n\n\n\nOther possibilities (see \nXtend documentation\n) \nallow to use static methods in a similar way (\"extension imports\") which can\nbe imported by other modules: \n\"import static extension package.Type.printNTimes\".\n\n\nDispatch methods\n\n\nA method (used as extension of not) can be marked with the keyword \n\"\ndispatch\n\". If such a method is defined multiple times with different \nspecialized types as argument, the correct version of the method if called\ndepending what object is passed (runtime polymorphy). The code behaves if\nan \"if obj instanceof TYPE\" is called to determine which version has to be called.\n\n\nMisc\n\n\n\n\n\u201e==\u201c vs. \u201e===\u201c (analogous \u201e!=\u201c vs. \u201e!==\u201c):\n\n\n\u201e==\u201c uses the method \"equals\" to determine the result.\n\n\n\u201e===\u201c checks if the identical object is referenced (like a pointer comparison).\n\n\n\n\n\n\nIt is possible to check if an optional modell element is present or not\n    by comparing it to null.\n\n\nIt is possible to check if a model element is not yet loaded\n    (eIsProxy==true).\n\n\n\n\nEMF Parent Relationship (model navigation)\n\n\nSometimes (while generating code or validating the model)\nit is useful to navigate to the parent of a model object.\nThis can be done with the attribute \"eContainer\" of every model\nelement. It may be necessary to cast this parent to an appropriate type\n(this can also happen via a dispatch method).\n\n\nList element access\n\n\nLists can be accessed, e.g., via \"head\" (the first element) or \"get(index)\"\n(the i.th element).\n\n\nFilter and map functions, lambdas and passing lambdas\n\n\nFilter functions can be used to filter a list (like the unix command grep). \nMap funtions can be used to transform a list of elements (like the unix \ncommand sed):\n\n\nresource\n.\nallContents\n\n    \n.\nfilter\n(\nEntity\n)\n\n    \n.\nmap\n[\nname\n]\n\n    \n.\njoin\n(\n', '\n))\n\n\n\n\n\n\nDetails:\n\n\n\n\n\"filter(TYPE)\" filters the list to yield all entries of type \"TYPE\".\n\n\n\"filter(LAMBDA)\" filters the list using the \"LAMBDA\" as selector (if the\n     LAMBDA returns true, the element is returned).\n\n\n\"map(LAMBDA)\" transforms each element using the \"LAMBDA\".\n\n\nFunctions expecting a lambda can be called ommiting the brackets \"(...)\".\n\n\nLambda have the following syntax \n\n\n\"[a | a.name]\" is the same as \"[name]\" or \"[it.name]\" (\"it\" is the \n    default parametername).\n\n\n\"return\" can be ommited: the last command yields the return value.",
            "title": "Xtend: Selected Aspects"
        },
        {
            "location": "/xtext_xtend/#xtend-selected-aspects",
            "text": "In addition to the features sketched in the \"code generation with Xtend\" section \nthis section provides some selected aspects we found useful for our work.",
            "title": "Xtend: Selected Aspects"
        },
        {
            "location": "/xtext_xtend/#extension-mechanism",
            "text": "Xtend has its name from the the fact that it allows to extend classes of\nthe language without using inheritance. There are different possibilities\nto achieve this task. One simple example of such an extended class \nis java.lang.String, which was extended by Xtend to provide \na method \"toFirstUpper\".  A simple possibility to achieve such an extension is to define a locally\nvisible method \" f( TypeX x,  ...) \" (see  Xtend documentation ).\nWith this, TypeX is extened by a method  f(...) .  def   printNTimes ( String   s ,   int   n )   { \n     for ( var   i = 0 ; i < n ; i ++)   println ( s )  }  ...      \n     \"Hello\" . printNTimes ( 3 )  ...   Other possibilities (see  Xtend documentation ) \nallow to use static methods in a similar way (\"extension imports\") which can\nbe imported by other modules: \n\"import static extension package.Type.printNTimes\".",
            "title": "Extension mechanism"
        },
        {
            "location": "/xtext_xtend/#dispatch-methods",
            "text": "A method (used as extension of not) can be marked with the keyword \n\" dispatch \". If such a method is defined multiple times with different \nspecialized types as argument, the correct version of the method if called\ndepending what object is passed (runtime polymorphy). The code behaves if\nan \"if obj instanceof TYPE\" is called to determine which version has to be called.",
            "title": "Dispatch methods"
        },
        {
            "location": "/xtext_xtend/#misc",
            "text": "\u201e==\u201c vs. \u201e===\u201c (analogous \u201e!=\u201c vs. \u201e!==\u201c):  \u201e==\u201c uses the method \"equals\" to determine the result.  \u201e===\u201c checks if the identical object is referenced (like a pointer comparison).    It is possible to check if an optional modell element is present or not\n    by comparing it to null.  It is possible to check if a model element is not yet loaded\n    (eIsProxy==true).",
            "title": "Misc"
        },
        {
            "location": "/xtext_xtend/#emf-parent-relationship-model-navigation",
            "text": "Sometimes (while generating code or validating the model)\nit is useful to navigate to the parent of a model object.\nThis can be done with the attribute \"eContainer\" of every model\nelement. It may be necessary to cast this parent to an appropriate type\n(this can also happen via a dispatch method).",
            "title": "EMF Parent Relationship (model navigation)"
        },
        {
            "location": "/xtext_xtend/#list-element-access",
            "text": "Lists can be accessed, e.g., via \"head\" (the first element) or \"get(index)\"\n(the i.th element).",
            "title": "List element access"
        },
        {
            "location": "/xtext_xtend/#filter-and-map-functions-lambdas-and-passing-lambdas",
            "text": "Filter functions can be used to filter a list (like the unix command grep). \nMap funtions can be used to transform a list of elements (like the unix \ncommand sed):  resource . allContents \n     . filter ( Entity ) \n     . map [ name ] \n     . join ( ', ' ))   Details:   \"filter(TYPE)\" filters the list to yield all entries of type \"TYPE\".  \"filter(LAMBDA)\" filters the list using the \"LAMBDA\" as selector (if the\n     LAMBDA returns true, the element is returned).  \"map(LAMBDA)\" transforms each element using the \"LAMBDA\".  Functions expecting a lambda can be called ommiting the brackets \"(...)\".  Lambda have the following syntax   \"[a | a.name]\" is the same as \"[name]\" or \"[it.name]\" (\"it\" is the \n    default parametername).  \"return\" can be ommited: the last command yields the return value.",
            "title": "Filter and map functions, lambdas and passing lambdas"
        },
        {
            "location": "/xtext_scoping/",
            "text": "Xtext Scoping\n\n\nIn this seciton you will learn the following:\n\n\n\n\nWhat scoping means and where you need it.\n\n\nHow to customize scoping for special lookups of local elements.\n\n\nHow to select scope providers to handle models distributed across \n   different files.\n\n\n\n\nScoping: What is it and where do I need it?\n\n\nScoping is always relevant, when a reference \n(e.g., \"Thing: ref=[OtherThing]\") is resolved after \nparsing the model text. Details see \nbasics.md\n.\n\n\nScoping: Global identification of elements\n\n\nWhen you identify an element by name (in order to reference it) you use\nthe default scope provider of Xtext. It resembles the Java scope (based on\npackages separated by dots).\n\n\nProblem\n\n\nIn order to make use of the full qualified name of an element the default\nformat of references is not enough to formulate the name (because dots are not\npart of this default format):\n\n\nModel\n:\n \npackages\n+=\nPack\n*\n;\n\n\nPack\n:\n \n'package'\n \nname\n=\nID\n \n'{'\n \n(\ndefs\n+=\nDef\n \n|\n \ncalls\n+=\nCall\n)*\n \n'}'\n;\n\n\nDef\n:\n \n'def'\n \nname\n=\nID\n;\n\n\nCall\n:\n \n'call'\n \nref\n=\n[\nDef\n];\n \n// same as \"ref=[Def|ID]\"\n\n\n\n\n\n\nWith this grammar the default format \"ID\" is used to reference A objects\nin B objects.\n\n\nThe following will work because all elements are in the same hierachical\nelement (Package):\n\n\npackage p1 {\n    def a1\n    def a2\n    call a1\n    call a2\n}\n\n\n\n\n\nThe following will not work\n\n\npackage p1 {\n    def a1\n}\npackage p2 {\n    def a2\n    call a1 // will not work (a1 is located in p1) \n    call a2\n}\n\n\n\n\n\nSolution\n\n\nModel\n:\n \npackages\n+=\nPack\n*\n;\n\n\nPack\n:\n \n'package'\n \nname\n=\nID\n \n'{'\n \n(\ndefs\n+=\nDef\n \n|\n \ncalls\n+=\nCall\n)*\n \n'}'\n;\n\n\nDef\n:\n \n'def'\n \nname\n=\nID\n;\n\n\nCall\n:\n \n'call'\n \nref\n=\n[\nDef|FQN\n];\n\n\nFQN\n \nhidden()\n:\n \nID\n(\n'.'\n \nID\n)*\n;\n\n\n\n\n\n\nHere we allow the format of the reference to be a dot-separated name.\n\n\nNote\n: The optional \"hidden()\" controls which tokens are ignored (hidden). \nHidden tokens are, e.g., whitespaces and comments by default. \nWith \"hidden()\" no such tokens are ignored, thus, not allowing, e.g.,\nwhitespaces between the dot separated parts of a name.*\n\n\nWith this, the default scope provider allows models as in the following example:\n\n\npackage p1 {\n    def a1\n}\npackage p2 {\n    def a2\n    call p1.a1  \n    call a2\n}\n\n\n\n\n\nModels distributed across multiple files\n\n\nWhen distributing the model across different file, you can control\nhow model elements are allowed to reference other model elements in \ndifferent model files.\n\n\nDefaultGlobalScopeProvider \"make everything visible\"\n\n\nThe default scope provider allows referencing any model element in the \navailable resources. In case of an eclipse project with model files,\nthose resources consist of all model files in the current project. Thus,\nyou can reference any model element without any import or include statement.\n\n\nFor example, elements from p1.mydsl:\n\n\npackage p1 {\n    def a1\n}\n\n\n\n\n\nmay be referenced by elements in p2.mydsl:\n\n\npackage p2 {\n    call p1.a1  \n}\n\n\n\n\n\nNote:\n When creating a standalone compiler for your DSL, you do not\nhave such things as a workspace. In this case, you can manually provide\nthis information, as illustrated in \n\nxtext_deploy_command_line.md\n.\n\n\nImportUriGlobalScopeProvider \"#include <other>\"\n\n\nYou can easily change the visiblity to provide a language with explicit import\nstatements; see e.g. \n(Mooij et al, 2017b)\n.\n\n\nThese steps sum up as follows for a simple default project:\n\n\n\n\n\n\nAdd the \"ImportUriValidator\" in your mwe2-file (side-by-side to your grammar).\n\n\n...\nvalidator = {\n    // composedCheck = \"org.eclipse.xtext.validation.NamesAreUniqueValidator\"\n    composedCheck = \"org.eclipse.xtext.validation.ImportUriValidator\"\n}\n...\n\n\n\n\n\n\n\n\n\nModify your grammar to include an import statement with a special \n    \"importURI\"-field.\n\n\nModel\n:\n \nimports\n+=\nImport\n*\n \npackages\n+=\nPack\n*\n;\n\n\nImport\n:\n \n\"import\"\n \nimportURI\n=\nSTRING\n\n\n...\n\n\n\n\n\n\n\n\n\n\nadd the following to your *RuntimeModule (located side-by-side to your\n      grammar)\n\n\noverride\n \nbindIGlobalScopeProvider\n()\n \n{\n\n    \nImportUriGlobalScopeProvider\n\n\n}\n\n\n\n\n\n\n\n\n\n\nWith this addition, the example above needs to be changed in file p2.mydsl:\n\n\nimport\n \n\"p1.mydsl\"\n\n\n\npackage\n \np2\n \n{\n\n    \ncall\n \np1\n.\na1\n\n\n}\n\n\n\n\n\n\nCustomize lookup of local elements\n\n\nThe following example illustrates a \nsimple object oriented language, where you can define classes, \ncreate instances, and call methods of classes associated to that instances.\n\n\npackage p1 {\n    class C1 {\n        def a1\n        def b1\n    }\n    instance i1: C1\n    call i1->a1\n    call i1->b1\n}\n\n\n\n\n\nWhen model references point to relative model element locations, you need a \ncustom scope provider for that reference. The reference to \"a1\" in \"i1->a1\"\ncannot be resolved by the default scope provider, because the semantics of\nthe call are not defined by the grammar.\n\n\nIn the example shown, \"i1->a1\"\npoints to \"a1\", which can be resolved by following the reference to the\ndefinition of \"i1\", and then following there the reference to \"C1\", which\ncontains the desired definition of \"a1\".\n\n\nModel\n:\n \nimports\n+=\nImport\n*\n \npackages\n+=\nPack\n*\n;\n\n\nPack\n:\n \n'package'\n \nname\n=\nID\n \n'{'\n \n\n\n    \n(\nclass\n+=\nClass\n \n|\n \ninstances\n+=\nInstance\n \n|\n \ncalls\n+=\nCall\n)*\n \n\n\n    \n'}'\n;\n\n\nClass\n:\n \n'class'\n \nname\n=\nID\n \n\"{\"\n \ndefs\n+=\nDef\n*\n \n\"}\"\n;\n\n\nDef\n:\n \n'def'\n \nname\n=\nID\n;\n\n\nInstance\n:\n \n'instance'\n \nname\n=\nID\n \n':'\n \ntype\n=\n[\nClass|FQN\n];\n\n\nCall\n:\n \n'call'\n \ninstance\n=\n[\nInstance|FQN\n]\n \n'->'\n \nref\n=\n[\nDef\n];\n\n\nFQN\n \nhidden()\n:\n \nID\n(\n'.'\n \nID\n)*\n;\n\n\nImport\n:\n \n\"import\"\n \nimportURI\n=\nSTRING\n;\n\n\n\n\n\n\n\n\nTo resolve the reference of the \"call\", you need to specify a custom scope\nprovider in \"scoping/MyDslScopeProvider.xtend\", side-by-side to your grammar:\n\n\n\n\nYou get the \"object\" (in our case the \"call\"-object) and a \"reference\"\n   identifying the part of grammar representing the reference to be resolved \n   (in our case the attribute \"ref\" of the \"Call\").\n\n\nUsing \"object\" and \"reference\" you can decide where to handle scoping\n   here, or delegating scoping to the default implementation \n   \"return super.getScope(...)\".\n\n\nBased on the object you can implement your scoping logic defining\n    what objects are visible (e.g. all \"Def\"-objects in \n    \"call.instance.type.defs\"). Use Scopes.scopeFor(...) to return your\n    selection.\n\n\nWhen you decide that no elements are visible, return \"IScope.NULLSCOPE\".\nclass\n \nMyDslScopeProvider\n \nextends\n \nAbstractMyDslScopeProvider\n \n{\n\n    \noverride\n \ngetScope\n(\nEObject\n \nobject\n,\n \nEReference\n \nref\n)\n \n{\n\n        \nif\n \n(\nref\n \n==\n \nMyDslPackage\n.\nLiterals\n.\nCALL__REF\n)\n \n{\n\n            \nval\n \ncall\n \n=\n \nobject\n \nas\n \nCall\n\n            \nreturn\n \nScopes\n.\nscopeFor\n(\ncall\n.\ninstance\n.\ntype\n.\ndefs\n)\n \n        \n}\n\n        \nreturn\n \nsuper\n.\ngetScope\n(\nobject\n,\n \nref\n)\n\n    \n}\n   \n\n}\n\n\n\n\n\n\n\n\n\n\nExercise \"modeling inheritance\"\n\n\nHere, you have to extend the language above to support inheritance. The \nfollowing example should parse.\n\n\npackage p1 {\n    class C1 {\n        def a1\n    }\n    class C2 extends C1 {\n        def b1\n    }\n    instance i1: C1\n    instance i2: C2\n    call i1->a1\n    //call i1->b1 // error\n    call i2->a1\n    call i2->b1\n}\n\n\n\n\n\nThe basic steps are as follows:\n\n\n\n\nExtend your grammar to support the optional \"extends\" syntax.\n\n\nExtend your scope provider to concatenate the list of \"Def\" elements\n   of a class with the \"Def\" elements of a base class (recursively). Hint:\n   java.util.Lists<T> can be concatenated using \"+\".\n\n\n\n\nThis unittest can be used to check the correct functionality:\n\n\n/*\n\n\n * generated by Xtext 2.14.0\n\n\n */\n\n\npackage\n \norg\n.\nxtext\n.\nexample\n.\nmydsl\n.\ntests\n\n\n\nimport\n \ncom.google.inject.Inject\n\n\nimport\n \norg.eclipse.xtext.testing.InjectWith\n\n\nimport\n \norg.eclipse.xtext.testing.XtextRunner\n\n\nimport\n \norg.eclipse.xtext.testing.util.ParseHelper\n\n\nimport\n \nstatic\n \nextension\n \norg\n.\njunit\n.\nAssert\n.*\n\n\nimport\n \norg.junit.Test\n\n\nimport\n \norg.junit.runner.RunWith\n\n\nimport\n \norg.xtext.example.mydsl.myDsl.Model\n\n\nimport\n \norg.eclipse.xtext.testing.validation.ValidationTestHelper\n\n\nimport\n \norg.xtext.example.mydsl.myDsl.MyDslPackage\n\n\n\n@RunWith\n(\nXtextRunner\n)\n\n\n@InjectWith\n(\nMyDslInjectorProvider\n)\n\n\nclass\n \nMyDslParsingTest\n \n{\n\n    \n@Inject\n \nextension\n\n    \nParseHelper\n<\nModel\n>\n \nparseHelper\n\n    \n@Inject\n \nextension\n\n    \nValidationTestHelper\n \ntestHelper\n;\n\n\n    \n@Test\n\n    \ndef\n \nvoid\n \nloadModel\n()\n \n{\n\n        \nval\n \nresult\n \n=\n \nparseHelper\n.\nparse\n(\n'''\n\n\n            package p1 {\n\n\n                class C1 {\n\n\n                    def a1\n\n\n                }\n\n\n                class C2 extends C1 {\n\n\n                    def b1\n\n\n                }\n\n\n                instance i1: C1\n\n\n                instance i2: C2\n\n\n                call i1->a1\n\n\n                //call i1->b1 // error\n\n\n                call i2->a1\n\n\n                call i2->b1\n\n\n            }\n\n\n        '''\n)\n\n        \nresult\n.\nassertNotNull\n\n        \nresult\n.\nassertNoErrors\n\n\n        \n// check call references:\n\n        \nassertTrue\n(\n \nresult\n.\npackages\n.\nhead\n.\nclass_\n.\nhead\n.\ndefs\n.\nhead\n \n            \n==\n \nresult\n.\npackages\n.\nhead\n.\ncalls\n.\nget\n(\n0\n).\nref\n\n        \n)\n\n        \nassertTrue\n(\n \nresult\n.\npackages\n.\nhead\n.\nclass_\n.\nhead\n.\ndefs\n.\nhead\n \n            \n==\n \nresult\n.\npackages\n.\nhead\n.\ncalls\n.\nget\n(\n1\n).\nref\n\n        \n)\n\n        \nassertTrue\n(\n \nresult\n.\npackages\n.\nhead\n.\nclass_\n.\nhead\n.\ndefs\n.\nhead\n \n            \n!=\n \nresult\n.\npackages\n.\nhead\n.\ncalls\n.\nget\n(\n2\n).\nref\n\n        \n)\n\n        \nassertTrue\n(\n \nresult\n.\npackages\n.\nhead\n.\nclass_\n.\nlast\n.\ndefs\n.\nhead\n \n            \n==\n \nresult\n.\npackages\n.\nhead\n.\ncalls\n.\nget\n(\n2\n).\nref\n\n        \n)\n\n    \n}\n\n\n    \n@Test\n\n    \ndef\n \nvoid\n \nloadModelWithError\n()\n \n{\n\n        \nval\n \nresult\n \n=\n \nparseHelper\n.\nparse\n(\n'''\n\n\n            package p1 {\n\n\n                class C1 {\n\n\n                    def a1\n\n\n                }\n\n\n                class C2 extends C1 {\n\n\n                    def b1\n\n\n                }\n\n\n                instance i1: C1\n\n\n                instance i2: C2\n\n\n                call i1->a1\n\n\n                call i1->b1 // error\n\n\n                call i2->a1\n\n\n                call i2->b1\n\n\n            }\n\n\n        '''\n)\n\n        \nresult\n.\nassertNotNull\n\n        \nresult\n.\nassertError\n(\nMyDslPackage\n.\neINSTANCE\n.\ncall\n,\n \n            \norg\n.\neclipse\n.\nxtext\n.\ndiagnostics\n.\nDiagnostic\n.\nLINKING_DIAGNOSTIC\n\n        \n)\n\n    \n}\n\n\n}\n\n\n\n\n\n\nNote: When you do not know the error code (\"LINKING_DIAGNOSTIC\") you can\ncheck the output of your unittest to get (and check) the information.\nFor custom validators, the error code is the one passed to the error/warning \nfunction within your validation code.",
            "title": "Scoping"
        },
        {
            "location": "/xtext_scoping/#xtext-scoping",
            "text": "In this seciton you will learn the following:   What scoping means and where you need it.  How to customize scoping for special lookups of local elements.  How to select scope providers to handle models distributed across \n   different files.",
            "title": "Xtext Scoping"
        },
        {
            "location": "/xtext_scoping/#scoping-what-is-it-and-where-do-i-need-it",
            "text": "Scoping is always relevant, when a reference \n(e.g., \"Thing: ref=[OtherThing]\") is resolved after \nparsing the model text. Details see  basics.md .",
            "title": "Scoping: What is it and where do I need it?"
        },
        {
            "location": "/xtext_scoping/#scoping-global-identification-of-elements",
            "text": "When you identify an element by name (in order to reference it) you use\nthe default scope provider of Xtext. It resembles the Java scope (based on\npackages separated by dots).",
            "title": "Scoping: Global identification of elements"
        },
        {
            "location": "/xtext_scoping/#problem",
            "text": "In order to make use of the full qualified name of an element the default\nformat of references is not enough to formulate the name (because dots are not\npart of this default format):  Model :   packages += Pack * ;  Pack :   'package'   name = ID   '{'   ( defs += Def   |   calls += Call )*   '}' ;  Def :   'def'   name = ID ;  Call :   'call'   ref = [ Def ];   // same as \"ref=[Def|ID]\"   With this grammar the default format \"ID\" is used to reference A objects\nin B objects.  The following will work because all elements are in the same hierachical\nelement (Package):  package p1 {\n    def a1\n    def a2\n    call a1\n    call a2\n}  The following will not work  package p1 {\n    def a1\n}\npackage p2 {\n    def a2\n    call a1 // will not work (a1 is located in p1) \n    call a2\n}",
            "title": "Problem"
        },
        {
            "location": "/xtext_scoping/#solution",
            "text": "Model :   packages += Pack * ;  Pack :   'package'   name = ID   '{'   ( defs += Def   |   calls += Call )*   '}' ;  Def :   'def'   name = ID ;  Call :   'call'   ref = [ Def|FQN ];  FQN   hidden() :   ID ( '.'   ID )* ;   Here we allow the format of the reference to be a dot-separated name.  Note : The optional \"hidden()\" controls which tokens are ignored (hidden). \nHidden tokens are, e.g., whitespaces and comments by default. \nWith \"hidden()\" no such tokens are ignored, thus, not allowing, e.g.,\nwhitespaces between the dot separated parts of a name.*  With this, the default scope provider allows models as in the following example:  package p1 {\n    def a1\n}\npackage p2 {\n    def a2\n    call p1.a1  \n    call a2\n}",
            "title": "Solution"
        },
        {
            "location": "/xtext_scoping/#models-distributed-across-multiple-files",
            "text": "When distributing the model across different file, you can control\nhow model elements are allowed to reference other model elements in \ndifferent model files.",
            "title": "Models distributed across multiple files"
        },
        {
            "location": "/xtext_scoping/#defaultglobalscopeprovider-make-everything-visible",
            "text": "The default scope provider allows referencing any model element in the \navailable resources. In case of an eclipse project with model files,\nthose resources consist of all model files in the current project. Thus,\nyou can reference any model element without any import or include statement.  For example, elements from p1.mydsl:  package p1 {\n    def a1\n}  may be referenced by elements in p2.mydsl:  package p2 {\n    call p1.a1  \n}  Note:  When creating a standalone compiler for your DSL, you do not\nhave such things as a workspace. In this case, you can manually provide\nthis information, as illustrated in  xtext_deploy_command_line.md .",
            "title": "DefaultGlobalScopeProvider \"make everything visible\""
        },
        {
            "location": "/xtext_scoping/#importuriglobalscopeprovider-include-other",
            "text": "You can easily change the visiblity to provide a language with explicit import\nstatements; see e.g.  (Mooij et al, 2017b) .  These steps sum up as follows for a simple default project:    Add the \"ImportUriValidator\" in your mwe2-file (side-by-side to your grammar).  ...\nvalidator = {\n    // composedCheck = \"org.eclipse.xtext.validation.NamesAreUniqueValidator\"\n    composedCheck = \"org.eclipse.xtext.validation.ImportUriValidator\"\n}\n...    Modify your grammar to include an import statement with a special \n    \"importURI\"-field.  Model :   imports += Import *   packages += Pack * ;  Import :   \"import\"   importURI = STRING  ...     add the following to your *RuntimeModule (located side-by-side to your\n      grammar)  override   bindIGlobalScopeProvider ()   { \n     ImportUriGlobalScopeProvider  }     With this addition, the example above needs to be changed in file p2.mydsl:  import   \"p1.mydsl\"  package   p2   { \n     call   p1 . a1  }",
            "title": "ImportUriGlobalScopeProvider \"#include &lt;other&gt;\""
        },
        {
            "location": "/xtext_scoping/#customize-lookup-of-local-elements",
            "text": "The following example illustrates a \nsimple object oriented language, where you can define classes, \ncreate instances, and call methods of classes associated to that instances.  package p1 {\n    class C1 {\n        def a1\n        def b1\n    }\n    instance i1: C1\n    call i1->a1\n    call i1->b1\n}  When model references point to relative model element locations, you need a \ncustom scope provider for that reference. The reference to \"a1\" in \"i1->a1\"\ncannot be resolved by the default scope provider, because the semantics of\nthe call are not defined by the grammar.  In the example shown, \"i1->a1\"\npoints to \"a1\", which can be resolved by following the reference to the\ndefinition of \"i1\", and then following there the reference to \"C1\", which\ncontains the desired definition of \"a1\".  Model :   imports += Import *   packages += Pack * ;  Pack :   'package'   name = ID   '{'         ( class += Class   |   instances += Instance   |   calls += Call )*         '}' ;  Class :   'class'   name = ID   \"{\"   defs += Def *   \"}\" ;  Def :   'def'   name = ID ;  Instance :   'instance'   name = ID   ':'   type = [ Class|FQN ];  Call :   'call'   instance = [ Instance|FQN ]   '->'   ref = [ Def ];  FQN   hidden() :   ID ( '.'   ID )* ;  Import :   \"import\"   importURI = STRING ;    To resolve the reference of the \"call\", you need to specify a custom scope\nprovider in \"scoping/MyDslScopeProvider.xtend\", side-by-side to your grammar:   You get the \"object\" (in our case the \"call\"-object) and a \"reference\"\n   identifying the part of grammar representing the reference to be resolved \n   (in our case the attribute \"ref\" of the \"Call\").  Using \"object\" and \"reference\" you can decide where to handle scoping\n   here, or delegating scoping to the default implementation \n   \"return super.getScope(...)\".  Based on the object you can implement your scoping logic defining\n    what objects are visible (e.g. all \"Def\"-objects in \n    \"call.instance.type.defs\"). Use Scopes.scopeFor(...) to return your\n    selection.  When you decide that no elements are visible, return \"IScope.NULLSCOPE\". class   MyDslScopeProvider   extends   AbstractMyDslScopeProvider   { \n     override   getScope ( EObject   object ,   EReference   ref )   { \n         if   ( ref   ==   MyDslPackage . Literals . CALL__REF )   { \n             val   call   =   object   as   Call \n             return   Scopes . scopeFor ( call . instance . type . defs )  \n         } \n         return   super . getScope ( object ,   ref ) \n     }     }",
            "title": "Customize lookup of local elements"
        },
        {
            "location": "/xtext_scoping/#exercise-modeling-inheritance",
            "text": "Here, you have to extend the language above to support inheritance. The \nfollowing example should parse.  package p1 {\n    class C1 {\n        def a1\n    }\n    class C2 extends C1 {\n        def b1\n    }\n    instance i1: C1\n    instance i2: C2\n    call i1->a1\n    //call i1->b1 // error\n    call i2->a1\n    call i2->b1\n}  The basic steps are as follows:   Extend your grammar to support the optional \"extends\" syntax.  Extend your scope provider to concatenate the list of \"Def\" elements\n   of a class with the \"Def\" elements of a base class (recursively). Hint:\n   java.util.Lists<T> can be concatenated using \"+\".   This unittest can be used to check the correct functionality:  /*   * generated by Xtext 2.14.0   */  package   org . xtext . example . mydsl . tests  import   com.google.inject.Inject  import   org.eclipse.xtext.testing.InjectWith  import   org.eclipse.xtext.testing.XtextRunner  import   org.eclipse.xtext.testing.util.ParseHelper  import   static   extension   org . junit . Assert .*  import   org.junit.Test  import   org.junit.runner.RunWith  import   org.xtext.example.mydsl.myDsl.Model  import   org.eclipse.xtext.testing.validation.ValidationTestHelper  import   org.xtext.example.mydsl.myDsl.MyDslPackage  @RunWith ( XtextRunner )  @InjectWith ( MyDslInjectorProvider )  class   MyDslParsingTest   { \n     @Inject   extension \n     ParseHelper < Model >   parseHelper \n     @Inject   extension \n     ValidationTestHelper   testHelper ; \n\n     @Test \n     def   void   loadModel ()   { \n         val   result   =   parseHelper . parse ( '''              package p1 {                  class C1 {                      def a1                  }                  class C2 extends C1 {                      def b1                  }                  instance i1: C1                  instance i2: C2                  call i1->a1                  //call i1->b1 // error                  call i2->a1                  call i2->b1              }          ''' ) \n         result . assertNotNull \n         result . assertNoErrors \n\n         // check call references: \n         assertTrue (   result . packages . head . class_ . head . defs . head  \n             ==   result . packages . head . calls . get ( 0 ). ref \n         ) \n         assertTrue (   result . packages . head . class_ . head . defs . head  \n             ==   result . packages . head . calls . get ( 1 ). ref \n         ) \n         assertTrue (   result . packages . head . class_ . head . defs . head  \n             !=   result . packages . head . calls . get ( 2 ). ref \n         ) \n         assertTrue (   result . packages . head . class_ . last . defs . head  \n             ==   result . packages . head . calls . get ( 2 ). ref \n         ) \n     } \n\n     @Test \n     def   void   loadModelWithError ()   { \n         val   result   =   parseHelper . parse ( '''              package p1 {                  class C1 {                      def a1                  }                  class C2 extends C1 {                      def b1                  }                  instance i1: C1                  instance i2: C2                  call i1->a1                  call i1->b1 // error                  call i2->a1                  call i2->b1              }          ''' ) \n         result . assertNotNull \n         result . assertError ( MyDslPackage . eINSTANCE . call ,  \n             org . eclipse . xtext . diagnostics . Diagnostic . LINKING_DIAGNOSTIC \n         ) \n     }  }   Note: When you do not know the error code (\"LINKING_DIAGNOSTIC\") you can\ncheck the output of your unittest to get (and check) the information.\nFor custom validators, the error code is the one passed to the error/warning \nfunction within your validation code.",
            "title": "Exercise \"modeling inheritance\""
        },
        {
            "location": "/xtext_modularization/",
            "text": "Xtext: Model Modularization\n\n\nIn this section we present possibilities to modularize your model\ndata across multiple files, in order to reuse model data and to divide\nmodel data into smaller parts.\n\n\nModularization within the same Meta Model\n\n\nThis topic is covered in \nxtext_scoping.md\n.\n\n\nReferencing Model Elements form other Meta Models\n\n\nWhen you have ab existing metamodel (an Xtext language, e.g., \n\"org.xtext.example.mydsl\"), you can create another language referencing this\nexisting language.\n\n\nIn the new language (in eclipse a new project, created side-by-side to the \nexisting language, e.g., \"org.xtext.example.mydsl1.MyDsl1\"; details see\n\n(Mooij et al, 2017b)\n):\n\n\n\n\nAdd plugin dependency in MANIFEST.MF in your new language project \n   (e.g., \"org.xtext.example.mydsl1\")\n\n\nopen org.xtext.example.mydsl1/META_INF/MANIFEST.MF\n\n\nclick on \"Dependencies\" \n\n\n\"Add...\" in \"Required Plug-Ins\"\n\n\nselect the existing language and the ui package\n     (e.g. \"org.xtext.example.mydsl\" and \"org.xtext.example.mydsl.ui\")\n\n\nsave MANIFEST.MF (CTRL-S)\n\n\n\n\n\n\nAdd plugin dependency in MANIFEST.MF of your new \"ui\" project (e.g.,\n  \"org.xtext.example.mydsl1.ui\").\n\n\nsame as for the language project.\n\n\n\n\n\n\n\n\nIn the mwe2.file (side-by-side to the grammar of your new language)\n\n\n\n\nadd to section \"language\" (after \"name\"; you can check the path and the \n     file name in your existing language)\nreferencedResource = \"platform:/resource/org.xtext.example.mydsl/model/generated/MyDsl.genmodel\"\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn your new grammar, import the existing language (check the grammar of \n   the existing language for the URL). You can reference elements from your\n   exisiting language as shown below:\n\n\nimport\n \n\"http://www.xtext.org/example/mydsl/MyDsl\"\n \nas\n \nexistingDsl\n\n\n...\n\n\nGreeting\n:\n \n'Hello'\n \n'-->'\n \nref\n=\n[\nexistingDsl\n::\nGreeting\n];\n\n\n\n\n\n\n\n\n\n\nNote: Do not forget to have the \"Build Automatically\" enabled in the eclipse \nmenu \"Project\".",
            "title": "Modularization"
        },
        {
            "location": "/xtext_modularization/#xtext-model-modularization",
            "text": "In this section we present possibilities to modularize your model\ndata across multiple files, in order to reuse model data and to divide\nmodel data into smaller parts.",
            "title": "Xtext: Model Modularization"
        },
        {
            "location": "/xtext_modularization/#modularization-within-the-same-meta-model",
            "text": "This topic is covered in  xtext_scoping.md .",
            "title": "Modularization within the same Meta Model"
        },
        {
            "location": "/xtext_modularization/#referencing-model-elements-form-other-meta-models",
            "text": "When you have ab existing metamodel (an Xtext language, e.g., \n\"org.xtext.example.mydsl\"), you can create another language referencing this\nexisting language.  In the new language (in eclipse a new project, created side-by-side to the \nexisting language, e.g., \"org.xtext.example.mydsl1.MyDsl1\"; details see (Mooij et al, 2017b) ):   Add plugin dependency in MANIFEST.MF in your new language project \n   (e.g., \"org.xtext.example.mydsl1\")  open org.xtext.example.mydsl1/META_INF/MANIFEST.MF  click on \"Dependencies\"   \"Add...\" in \"Required Plug-Ins\"  select the existing language and the ui package\n     (e.g. \"org.xtext.example.mydsl\" and \"org.xtext.example.mydsl.ui\")  save MANIFEST.MF (CTRL-S)    Add plugin dependency in MANIFEST.MF of your new \"ui\" project (e.g.,\n  \"org.xtext.example.mydsl1.ui\").  same as for the language project.     In the mwe2.file (side-by-side to the grammar of your new language)   add to section \"language\" (after \"name\"; you can check the path and the \n     file name in your existing language) referencedResource = \"platform:/resource/org.xtext.example.mydsl/model/generated/MyDsl.genmodel\"      In your new grammar, import the existing language (check the grammar of \n   the existing language for the URL). You can reference elements from your\n   exisiting language as shown below:  import   \"http://www.xtext.org/example/mydsl/MyDsl\"   as   existingDsl  ...  Greeting :   'Hello'   '-->'   ref = [ existingDsl :: Greeting ];     Note: Do not forget to have the \"Build Automatically\" enabled in the eclipse \nmenu \"Project\".",
            "title": "Referencing Model Elements form other Meta Models"
        },
        {
            "location": "/xtext_deploy_command_line/",
            "text": "Xtext: deploy a command line version of the code generator\n\n\nGenerate a command line version of the code generator\n\n\nAdd the following entries to your mwe2 file (located side-by-side to your \ngrammar; see e.g. \n(Bettini, 2016)\n):\n\n\n...\nlanguage = StandardLanguage {\n    ...\n    generator = {\n        generateJavaMain = true\n    }\n    ...\n}\n...\n\n\n\n\n\nWhen running the mwe2 script (compiling your grammar; \nsee \nCompile and Run the Project\n), a Main.java\nfile is created in the generator namespace side-by-side to your grammar.\n\n\nOptional: Modify Main.java\n\n\nThe Main-class expects a model file to be processed: parsed, validated and\ngenerated code from the model.\n\n\n\n\nYou can manually set the destination path (\nchange \"src-gen\"\n to something \n    else).\n\n\nThere is no workspace for the model files; you must modify the Main.java \n    file in order to manually \nadd other model files\n (e.g. from some sub folder or \n    specified via the command line). \n    E.g.:\nprotected\n \nvoid\n \nrunGenerator\n(\nString\n \nmain_model_filename\n,\n \nString\n[]\n \nall_other_filenames\n)\n \n{\n\n    \n// Load the resource\n\n    \nResourceSet\n \nset\n \n=\n \nresourceSetProvider\n.\nget\n();\n\n    \nResource\n \nresource\n \n=\n \nset\n.\ngetResource\n(\nURI\n.\ncreateFileURI\n(\nmain_model_filename\n),\n \ntrue\n);\n\n    \nList\n<\nResource\n>\n \nall_resources\n \n=\n \nnew\n \nArrayList\n<\nResource\n>();\n\n    \nall_resources\n.\nadd\n(\nresource\n);\n\n\n    \n// Load all other requried resources\n\n    \nfor\n(\nString\n \nm\n:\nall_other_filenames\n)\n \n{\n\n        \nif\n \n(!\nm\n.\nequals\n(\nmain_model_filename\n))\n \n{\n\n            \nResource\n \nother\n \n=\n \nset\n.\ngetResource\n(\nURI\n.\ncreateFileURI\n(\nm\n),\n \ntrue\n);\n\n            \nall_resources\n.\nadd\n(\nother\n);\n\n        \n}\n\n    \n}\n\n\n    \n// Validate all resources\n\n    \nfor\n \n(\nResource\n \nr\n:\n \nall_resources\n)\n \n{\n\n        \nList\n<\nIssue\n>\n \nlist\n \n=\n \nvalidator\n.\nvalidate\n(\nr\n,\n \nCheckMode\n.\nALL\n,\n \nCancelIndicator\n.\nNullImpl\n);\n\n        \nif\n \n(!\nlist\n.\nisEmpty\n())\n \n{\n\n            \nfor\n \n(\nIssue\n \nissue\n \n:\n \nlist\n)\n \n{\n\n                \nSystem\n.\nerr\n.\nprintln\n(\nissue\n);\n\n            \n}\n\n            \nreturn\n;\n\n        \n}\n\n    \n}\n\n\n    \n// Configure and start the generator\n\n    \nfileAccess\n.\nsetOutputPath\n(\n\"src-gen/\"\n);\n\n    \nGeneratorContext\n \ncontext\n \n=\n \nnew\n \nGeneratorContext\n();\n\n    \ncontext\n.\nsetCancelIndicator\n(\nCancelIndicator\n.\nNullImpl\n);\n\n    \ngenerator\n.\ngenerate\n(\nresource\n,\n \nfileAccess\n,\n \ncontext\n);\n\n\n    \nSystem\n.\nout\n.\nprintln\n(\n\"Code generation finished.\"\n);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nManually create a runnable JAR file with the command line compiler\n\n\nIn eclipse you can \"\nExport\n\" your generator as \"\nRunnable JAR\n\":\n\n\n\n\nCreate a Run Configuration by right-clicking on your Main.java and select \n    \"Run as\" / \"Java Application\".\n\n\nThen right-click on the project containing the Main.java file and select \n    \"Export\", \"Runnable JAR file\".\n\n\nSelect \"Main\" in the \"Launch configurazion\".\n\n\nSelect \"Package required libraries into generated JAR file\".\n\n\nSpecify your destination JAR file name and click \"Finish\".\n\n\n\n\nCreate the command line compiler with gradle\n\n\nSee \nhttps://gitlab.com/Tim-S/xtext-dsl-headless-example\n\nfor a very nice and compact description: you will learn how to\ndeploy a command line version of the \"Hello World\" grammar\nusing a few lines of code.\n\n\nCreate the command line compiler with maven\n\n\n(work in progress)\n\n\n\n\nClose eclipse \n\n\nClone \nhttps://github.com/basilfx/xtext-standalone-maven-build\n\n   into some temporary directory (there is a good description there what to do)\n\n\nCopy the ...standalone-folder into your ...parent folder (side-by-side \n    to your other projects)\n\n\nRename the folder to match your project name (e.g. \n    \"org.xtext.example.mydsl.standalone\" to \n    \"org.example.domainmodel.standalone\")\n\n\nRename (find/replace) the project name (replace \"org.xtext.example.mydsl\"\n    with \"org.example.domainmodel\") in all files in the copied folder.\n\n\nAdd the new folder/module to the modules list in your master pom.xml file\n    (section \"modules\").\n\n\ntry \"mvn package\" in your master directory and check if the target in\n    the new standalone module is created. The generated JAR file can then be \n    tested as follows (assuming some model files are available):\njava -jar org.example.domainmodel.standalone/target/org.example.domainmodel.standalone-1.0.0-SNAPSHOT.jar *.dmodel\n\n\n\n\n\n\n\n\n\nNote: \n * no need to add (import) the standalone project into the ecplise \n    workspace.\n * You can use the standalone code generator as \"compiler\" in a Makefile\n    (like gcc). It will perform a model syntax check, a model validation and a \n    code generation.",
            "title": "Deploy a command line version"
        },
        {
            "location": "/xtext_deploy_command_line/#xtext-deploy-a-command-line-version-of-the-code-generator",
            "text": "",
            "title": "Xtext: deploy a command line version of the code generator"
        },
        {
            "location": "/xtext_deploy_command_line/#generate-a-command-line-version-of-the-code-generator",
            "text": "Add the following entries to your mwe2 file (located side-by-side to your \ngrammar; see e.g.  (Bettini, 2016) ):  ...\nlanguage = StandardLanguage {\n    ...\n    generator = {\n        generateJavaMain = true\n    }\n    ...\n}\n...  When running the mwe2 script (compiling your grammar; \nsee  Compile and Run the Project ), a Main.java\nfile is created in the generator namespace side-by-side to your grammar.",
            "title": "Generate a command line version of the code generator"
        },
        {
            "location": "/xtext_deploy_command_line/#optional-modify-mainjava",
            "text": "The Main-class expects a model file to be processed: parsed, validated and\ngenerated code from the model.   You can manually set the destination path ( change \"src-gen\"  to something \n    else).  There is no workspace for the model files; you must modify the Main.java \n    file in order to manually  add other model files  (e.g. from some sub folder or \n    specified via the command line). \n    E.g.: protected   void   runGenerator ( String   main_model_filename ,   String []   all_other_filenames )   { \n     // Load the resource \n     ResourceSet   set   =   resourceSetProvider . get (); \n     Resource   resource   =   set . getResource ( URI . createFileURI ( main_model_filename ),   true ); \n     List < Resource >   all_resources   =   new   ArrayList < Resource >(); \n     all_resources . add ( resource ); \n\n     // Load all other requried resources \n     for ( String   m : all_other_filenames )   { \n         if   (! m . equals ( main_model_filename ))   { \n             Resource   other   =   set . getResource ( URI . createFileURI ( m ),   true ); \n             all_resources . add ( other ); \n         } \n     } \n\n     // Validate all resources \n     for   ( Resource   r :   all_resources )   { \n         List < Issue >   list   =   validator . validate ( r ,   CheckMode . ALL ,   CancelIndicator . NullImpl ); \n         if   (! list . isEmpty ())   { \n             for   ( Issue   issue   :   list )   { \n                 System . err . println ( issue ); \n             } \n             return ; \n         } \n     } \n\n     // Configure and start the generator \n     fileAccess . setOutputPath ( \"src-gen/\" ); \n     GeneratorContext   context   =   new   GeneratorContext (); \n     context . setCancelIndicator ( CancelIndicator . NullImpl ); \n     generator . generate ( resource ,   fileAccess ,   context ); \n\n     System . out . println ( \"Code generation finished.\" );  }",
            "title": "Optional: Modify Main.java"
        },
        {
            "location": "/xtext_deploy_command_line/#manually-create-a-runnable-jar-file-with-the-command-line-compiler",
            "text": "In eclipse you can \" Export \" your generator as \" Runnable JAR \":   Create a Run Configuration by right-clicking on your Main.java and select \n    \"Run as\" / \"Java Application\".  Then right-click on the project containing the Main.java file and select \n    \"Export\", \"Runnable JAR file\".  Select \"Main\" in the \"Launch configurazion\".  Select \"Package required libraries into generated JAR file\".  Specify your destination JAR file name and click \"Finish\".",
            "title": "Manually create a runnable JAR file with the command line compiler"
        },
        {
            "location": "/xtext_deploy_command_line/#create-the-command-line-compiler-with-gradle",
            "text": "See  https://gitlab.com/Tim-S/xtext-dsl-headless-example \nfor a very nice and compact description: you will learn how to\ndeploy a command line version of the \"Hello World\" grammar\nusing a few lines of code.",
            "title": "Create the command line compiler with gradle"
        },
        {
            "location": "/xtext_deploy_command_line/#create-the-command-line-compiler-with-maven",
            "text": "(work in progress)   Close eclipse   Clone  https://github.com/basilfx/xtext-standalone-maven-build \n   into some temporary directory (there is a good description there what to do)  Copy the ...standalone-folder into your ...parent folder (side-by-side \n    to your other projects)  Rename the folder to match your project name (e.g. \n    \"org.xtext.example.mydsl.standalone\" to \n    \"org.example.domainmodel.standalone\")  Rename (find/replace) the project name (replace \"org.xtext.example.mydsl\"\n    with \"org.example.domainmodel\") in all files in the copied folder.  Add the new folder/module to the modules list in your master pom.xml file\n    (section \"modules\").  try \"mvn package\" in your master directory and check if the target in\n    the new standalone module is created. The generated JAR file can then be \n    tested as follows (assuming some model files are available): java -jar org.example.domainmodel.standalone/target/org.example.domainmodel.standalone-1.0.0-SNAPSHOT.jar *.dmodel    Note: \n * no need to add (import) the standalone project into the ecplise \n    workspace.\n * You can use the standalone code generator as \"compiler\" in a Makefile\n    (like gcc). It will perform a model syntax check, a model validation and a \n    code generation.",
            "title": "Create the command line compiler with maven"
        },
        {
            "location": "/xtext_deploy_plugin/",
            "text": "Deploy your DSL as eclispe plugin\n\n\nManual way to export and install a plugin\n\n\n\n\nWithin eclipse Export your language as \"Deployable features\".\n\n\nSelect the \"*.feature\" project of your language.\n\n\nSelect an archive file name to export your plugin\n\n\nIn the \"Options\" tab: \"Browse\" for \"Categorize repository\" and select the\n    \"*.repository\" project of your language.\n\n\nClick \"finish\".\n\n\n\n\nThen, you can install the plugin from the exported archive in an eclipse\ninstallation (You can, e.g., copy your eclipse folder, start the copy, install\nyour plugin and give the eclipse to another person).\n\n\nNotes: (1) When installing the plugin, it may be useful to disable \n\"Contact all update sites...\" (this caused problems in some examples). \n(2) You are also prompted, that the new plugin is not signed (you must \naccept this in order to continue).\n\n\nCreate a product\n\n\n(work in progress)",
            "title": "Deploy an eclispe plugin"
        },
        {
            "location": "/xtext_deploy_plugin/#deploy-your-dsl-as-eclispe-plugin",
            "text": "",
            "title": "Deploy your DSL as eclispe plugin"
        },
        {
            "location": "/xtext_deploy_plugin/#manual-way-to-export-and-install-a-plugin",
            "text": "Within eclipse Export your language as \"Deployable features\".  Select the \"*.feature\" project of your language.  Select an archive file name to export your plugin  In the \"Options\" tab: \"Browse\" for \"Categorize repository\" and select the\n    \"*.repository\" project of your language.  Click \"finish\".   Then, you can install the plugin from the exported archive in an eclipse\ninstallation (You can, e.g., copy your eclipse folder, start the copy, install\nyour plugin and give the eclipse to another person).  Notes: (1) When installing the plugin, it may be useful to disable \n\"Contact all update sites...\" (this caused problems in some examples). \n(2) You are also prompted, that the new plugin is not signed (you must \naccept this in order to continue).",
            "title": "Manual way to export and install a plugin"
        },
        {
            "location": "/xtext_deploy_plugin/#create-a-product",
            "text": "(work in progress)",
            "title": "Create a product"
        },
        {
            "location": "/xtext_howtos/",
            "text": "Xtext HOWTOs\n\n\nHere, we collect short snippets to solve common problems.\n\n\nDefine a named object\n\n\nUse the special attribute \"name\" in combination with\ndefault scope providers.\n\n\n...\n\n\nMyObj\n:\n \n'myobj'\n \nname\n=\nID\n\n\n\n\n\n\nDefine an optional attribute\n\n\nUse \"(...)?\". Note:\n  * Some types, like INT or enums have default values (like 0 for INTs) and, \n    thus, an unset value cannot be distinguished from, e.g., the value 0.\n  * Using helper objects (like \"Other\" in the example below) helps to detect\n    unset optional values, since the object is \"null\", if not set.\n\n\n...\n\n\nMyObj\n:\n \n'myobj'\n \nname\n=\nID\n \n(\noption_int\n=\nINT\n)?\n  \n(\noption_obj\n=\nOther\n)?\n;\n\n\nOther\n:\n \n'other'\n \nval\n=\nINT\n;\n\n\n\n\n\n\nDefine a boolean flag based on the presence of a keyword\n\n\nSee Xtext docu:\n\n\n...\n\n\nMyObj\n:\n \n'myobj'\n \nname\n=\nID\n \n(\noption_flag\n?=\n'flag_keyword'\n)?\n\n\n\n\n\n\nDefine an enum\n\n\nSee Xtext docu.\nNote: The first enum value is the default value.\n\n\n...\n\n\nMyObj\n:\n \n'myobj'\n \nname\n=\nID\n \n'='\n \nvalue\n=\nMyEnum\n;\n\n\nenum\n \nMyEnum\n:\n \nval1\n=\n'VAL1'\n|\nval2\n=\n'VAL2'\n|\nval3\n=\n'VAL3'\n;\n\n\n\n\n\n\nForce the creation of an object when no attributes are defined\n\n\nObject without attributes are not instantiated as objects in the model\nrepresentation. This can also happen, when all attributes are optional\nand not set in a concrete model (in this case you get a warning in your \ngrammar). Use \"{Rule-name}\" to force instantiation.\n\n\nMyObj\n:\n \n{\nMyObj\n}\n \n'myobj'\n \n(\nvalue\n=\nMyVal\n)?\n;\n\n\nMyVal\n:\n \ntext\n=\nSTING\n;\n\n\n\n\n\n\nDefine an attribute containing a list\n\n\n...\n\n\nModel\n:\n \nthings\n+=\nThing\n*\n;\n\n\nThing\n:\n \n'thing'\n \nname\n=\nID\n;\n\n\n\n\n\n\nAdd one element to a list\n\n\n...\n\n\nModel\n:\n \nthings\n+=\nThing\n;\n\n\nThing\n:\n \n'thing'\n \nname\n=\nID\n;\n\n\n\n\n\n\nDefine a comma separated list\n\n\n...\n\n\nModel\n:\n \nthings\n+=\nThing\n \n(\n','\n \nthings\n+=\nThing\n)*\n;\n\n\nThing\n:\n \n'thing'\n \nname\n=\nID\n;\n\n\n\n\n\n\nDefine an element to represent either a signed int or a float\n\n\nExample grammar snippet defining a 'myobj' containing a name and either a \nfloat or an integer value:\n\n\nimport\n \n\"http\n:\n//www.eclipse.org/emf/2002/Ecore\" as ecore\n\n\n...\n\n\nMyObj\n:\n \n'myobj'\n \nname\n=\nID\n \n'='\n \n(\nvalue\n=\nMyVal\n)?\n;\n\n\nMyVal\n:\n \nMyInt\n|\nMyFloat\n;\n\n\nMyInt\n:\n \nivalue\n=\nMYINT_T\n;\n\n\nMyFloat\n:\n \nfvalue\n=\nMYFLOAT_T\n;\n\n\nterminal\n \nMYINT_T\n \nreturns\n \necore\n::\nEInt\n:\n \n'-'\n?\nINT\n;\n\n\nterminal\n \nMYFLOAT_T\n \nreturns\n \necore\n::\nEFloat\n:\n \n'-'\n?\nINT\n'.'\nINT\n;\n\n\n\n\n\n\nWith the test illustrating the types (int/float):\n\n\n@Inject\n \nextension\n\n\nParseHelper\n<\nModel\n>\n \nparseHelper\n\n\n@Inject\n \nextension\n\n\nValidationTestHelper\n \ntestHelper\n;\n\n\n...\n    \n\n@Test\n \n\ndef\n \nvoid\n \ntestFloatInt\n()\n \n{\n\n    \nval\n \nresult\n \n=\n \n'''\n\n\n    myobj pi=3.1415\n\n\n    myobj N=4\n\n\n    '''\n.\nparse\n\n    \nresult\n.\nassertNotNull\n\n    \nresult\n.\nassertNoErrors\n\n\n    \nassertTrue\n(\n \nresult\n.\nobjs\n.\nhead\n.\nvalue\n \ninstanceof\n \nMyFloat\n \n)\n\n    \nval\n \nf\n \n=\n \n(\nresult\n.\nobjs\n.\nhead\n.\nvalue\n \nas\n \nMyFloat\n).\nfvalue\n\n    \nassertEquals\n(\n  \n3.1415\n,\n \nf\n,\n \n1\ne\n-\n4\n \n)\n\n\n    \nassertTrue\n(\n \nresult\n.\nobjs\n.\nlast\n.\nvalue\n \ninstanceof\n \nMyInt\n \n)\n\n    \nval\n \ni\n \n=\n \n(\nresult\n.\nobjs\n.\nlast\n.\nvalue\n \nas\n \nMyInt\n).\nivalue\n\n    \nassertEquals\n(\n  \n4\n,\n \ni\n \n)\n\n\n}\n\n\n\n\n\n\nAllow keywords as name of elements\n\n\nProblem\n: keywords (like 'myobj' or 'ref' in the example below) are not \nclassified as \"ID\" by the lexer. Thus, they cannot be used as ID (the default\nlexer token for references).\n\n\n...\n\n\nMyObj\n:\n \n'myobj'\n \nname\n=\nID\n \n\n\nRef\n:\n \n'ref'\n \n[\nMyObj\n];\n \n// same as [MyObj|ID]\n\n\n\n\n\n\nSolution\n: see https://blogs.itemis.com/en/xtext-hint-identifiers-conflicting-with-keywords\nfor more details. Define a VALID_ID, including the desired keywords to be \nallowed as name:\n\n\n...\n\n\nMyObj\n:\n \n'myobj'\n \nname\n=\nID\n \n\n\nRef\n:\n \n'ref'\n \n[\nMyObj|VALID_ID\n];\n\n\nVALID_ID\n:\n \nID\n|\n'ref'\n|\n'myobj'\n\n\n\n\n\n\nDefine a list of objects with the same base type\n\n\nExample:\n\n\nstruct Simple {\n    scalar x\n    array y[10]\n    scalar z\n}\n\n\n\n\n\nWith grammar:\n\n\n...\n\n\nStruct\n:\n \n'struct'\n \nname\n=\nID\n \n'{'\n \nattrs\n+=\nAttribute\n+\n \n'}'\n;\n\n\nAttribute\n:\n \nScalarAttribute\n|\nArrayAttribute\n;\n\n\nScalarAttribute\n:\n \n'scalar'\n \nname\n=\nID\n;\n\n\nArrayAttribute\n:\n \n'array'\n \nname\n=\nID\n \n'['\n \ndim\n=\nINT\n \n']'\n;\n\n\n\n\n\n\nAllow to model a mix of objects of unrelated type\n\n\nExample (same as in last example):\n\n\nstruct Simple {\n    scalar x\n    array y[10]\n    scalar z\n}\n\n\n\n\n\nWith grammar:\n\n\n...\n\n\nStruct\n:\n \n'struct'\n \nname\n=\nID\n \n'{'\n \n\n\n    \n(\ns\n+=\nScalarAttribute\n \n|\n \na\n+=\nArrayAttribute\n)*\n \n\n\n    \n'}'\n\n\n;\n\n\nScalarAttribute\n:\n \n'scalar'\n \nname\n=\nID\n;\n\n\nArrayAttribute\n:\n \n'array'\n \nname\n=\nID\n \n'['\n \ndim\n=\nINT\n \n']'\n;\n\n\n\n\n\n\nDefine multiline string attributes\n\n\nYou can use the \"->\" feature for terminals. You need to strip the \nleading and trailing '\"\"\"' when accessing the multiline string (e.g.,\nwith a xtend extension method).\n\n\nGrammar snippet:\n\n\n...\n\n\nMultlineInfo\n:\n \n'info'\n \ntext\n=\nMLTEXT\n;\n\n\nterminal\n \nMLTEXT\n:\n \n'\"\"\"'\n \n->\n \n'\"\"\"'\n;\n\n\n\n\n\n\nXtend code snippet and test:\n\n\nstatic\n \ndef\n \ngetMltext\n(\nMultlineInfo\n \ninfo\n)\n \n{\n\n    \ninfo\n.\ntext\n.\nreplaceAll\n(\n'^\"\"\"'\n,\n''\n).\nreplaceAll\n(\n'\"\"\"$'\n,\n''\n);\n\n\n}\n\n\n\n@Test\n \n\ndef\n \nvoid\n \ntestMlInfo\n()\n \n{\n\n    \nval\n \nresult\n \n=\n \n'''\n\n\n    info \"\"\"Hello World\"\"\"\n\n\n    info \"\"\"Hello Multiline\n\n\n    World\"\"\"\n\n\n    '''\n.\nparse\n\n    \nresult\n.\nassertNotNull\n\n    \nresult\n.\nassertNoErrors\n\n    \nassertEquals\n(\n \n'\"\"\"Hello World\"\"\"'\n,\n \nresult\n.\ninfos\n.\nhead\n.\ntext\n \n)\n\n    \nassertEquals\n(\n \n\"Hello World\"\n,\n \nresult\n.\ninfos\n.\nhead\n.\nmltext\n \n)\n\n    \nassertEquals\n(\n \n\"Hello Multiline\\nWorld\"\n,\n \nresult\n.\ninfos\n.\nlast\n.\nmltext\n \n)\n\n\n}\n\n\n\n\n\n\nFilter a list based on a type\n\n\nresource\n.\nallContents\n.\nfilter\n(\nEntity\n)\n\n\n\n\n\n\nFilter a list based on an attribute value\n\n\nresource\n.\nallContents\n.\nfilter\n(\nEntity\n).\nfilter\n[\nname\n=\n\"Tom\"\n]\n\n\n\n\n\n\nTransform a list\n\n\nresource\n.\nallContents\n.\nfilter\n(\nEntity\n).\nmap\n[\ne\n|\n'the name is '\n+\ne\n.\nname\n]",
            "title": "Xtext HOWTOs"
        },
        {
            "location": "/xtext_howtos/#xtext-howtos",
            "text": "Here, we collect short snippets to solve common problems.",
            "title": "Xtext HOWTOs"
        },
        {
            "location": "/xtext_howtos/#define-a-named-object",
            "text": "Use the special attribute \"name\" in combination with\ndefault scope providers.  ...  MyObj :   'myobj'   name = ID",
            "title": "Define a named object"
        },
        {
            "location": "/xtext_howtos/#define-an-optional-attribute",
            "text": "Use \"(...)?\". Note:\n  * Some types, like INT or enums have default values (like 0 for INTs) and, \n    thus, an unset value cannot be distinguished from, e.g., the value 0.\n  * Using helper objects (like \"Other\" in the example below) helps to detect\n    unset optional values, since the object is \"null\", if not set.  ...  MyObj :   'myobj'   name = ID   ( option_int = INT )?    ( option_obj = Other )? ;  Other :   'other'   val = INT ;",
            "title": "Define an optional attribute"
        },
        {
            "location": "/xtext_howtos/#define-a-boolean-flag-based-on-the-presence-of-a-keyword",
            "text": "See Xtext docu:  ...  MyObj :   'myobj'   name = ID   ( option_flag ?= 'flag_keyword' )?",
            "title": "Define a boolean flag based on the presence of a keyword"
        },
        {
            "location": "/xtext_howtos/#define-an-enum",
            "text": "See Xtext docu.\nNote: The first enum value is the default value.  ...  MyObj :   'myobj'   name = ID   '='   value = MyEnum ;  enum   MyEnum :   val1 = 'VAL1' | val2 = 'VAL2' | val3 = 'VAL3' ;",
            "title": "Define an enum"
        },
        {
            "location": "/xtext_howtos/#force-the-creation-of-an-object-when-no-attributes-are-defined",
            "text": "Object without attributes are not instantiated as objects in the model\nrepresentation. This can also happen, when all attributes are optional\nand not set in a concrete model (in this case you get a warning in your \ngrammar). Use \"{Rule-name}\" to force instantiation.  MyObj :   { MyObj }   'myobj'   ( value = MyVal )? ;  MyVal :   text = STING ;",
            "title": "Force the creation of an object when no attributes are defined"
        },
        {
            "location": "/xtext_howtos/#define-an-attribute-containing-a-list",
            "text": "...  Model :   things += Thing * ;  Thing :   'thing'   name = ID ;",
            "title": "Define an attribute containing a list"
        },
        {
            "location": "/xtext_howtos/#add-one-element-to-a-list",
            "text": "...  Model :   things += Thing ;  Thing :   'thing'   name = ID ;",
            "title": "Add one element to a list"
        },
        {
            "location": "/xtext_howtos/#define-a-comma-separated-list",
            "text": "...  Model :   things += Thing   ( ','   things += Thing )* ;  Thing :   'thing'   name = ID ;",
            "title": "Define a comma separated list"
        },
        {
            "location": "/xtext_howtos/#define-an-element-to-represent-either-a-signed-int-or-a-float",
            "text": "Example grammar snippet defining a 'myobj' containing a name and either a \nfloat or an integer value:  import   \"http : //www.eclipse.org/emf/2002/Ecore\" as ecore  ...  MyObj :   'myobj'   name = ID   '='   ( value = MyVal )? ;  MyVal :   MyInt | MyFloat ;  MyInt :   ivalue = MYINT_T ;  MyFloat :   fvalue = MYFLOAT_T ;  terminal   MYINT_T   returns   ecore :: EInt :   '-' ? INT ;  terminal   MYFLOAT_T   returns   ecore :: EFloat :   '-' ? INT '.' INT ;   With the test illustrating the types (int/float):  @Inject   extension  ParseHelper < Model >   parseHelper  @Inject   extension  ValidationTestHelper   testHelper ;  ...      @Test   def   void   testFloatInt ()   { \n     val   result   =   '''      myobj pi=3.1415      myobj N=4      ''' . parse \n     result . assertNotNull \n     result . assertNoErrors \n\n     assertTrue (   result . objs . head . value   instanceof   MyFloat   ) \n     val   f   =   ( result . objs . head . value   as   MyFloat ). fvalue \n     assertEquals (    3.1415 ,   f ,   1 e - 4   ) \n\n     assertTrue (   result . objs . last . value   instanceof   MyInt   ) \n     val   i   =   ( result . objs . last . value   as   MyInt ). ivalue \n     assertEquals (    4 ,   i   )  }",
            "title": "Define an element to represent either a signed int or a float"
        },
        {
            "location": "/xtext_howtos/#allow-keywords-as-name-of-elements",
            "text": "Problem : keywords (like 'myobj' or 'ref' in the example below) are not \nclassified as \"ID\" by the lexer. Thus, they cannot be used as ID (the default\nlexer token for references).  ...  MyObj :   'myobj'   name = ID    Ref :   'ref'   [ MyObj ];   // same as [MyObj|ID]   Solution : see https://blogs.itemis.com/en/xtext-hint-identifiers-conflicting-with-keywords\nfor more details. Define a VALID_ID, including the desired keywords to be \nallowed as name:  ...  MyObj :   'myobj'   name = ID    Ref :   'ref'   [ MyObj|VALID_ID ];  VALID_ID :   ID | 'ref' | 'myobj'",
            "title": "Allow keywords as name of elements"
        },
        {
            "location": "/xtext_howtos/#define-a-list-of-objects-with-the-same-base-type",
            "text": "Example:  struct Simple {\n    scalar x\n    array y[10]\n    scalar z\n}  With grammar:  ...  Struct :   'struct'   name = ID   '{'   attrs += Attribute +   '}' ;  Attribute :   ScalarAttribute | ArrayAttribute ;  ScalarAttribute :   'scalar'   name = ID ;  ArrayAttribute :   'array'   name = ID   '['   dim = INT   ']' ;",
            "title": "Define a list of objects with the same base type"
        },
        {
            "location": "/xtext_howtos/#allow-to-model-a-mix-of-objects-of-unrelated-type",
            "text": "Example (same as in last example):  struct Simple {\n    scalar x\n    array y[10]\n    scalar z\n}  With grammar:  ...  Struct :   'struct'   name = ID   '{'         ( s += ScalarAttribute   |   a += ArrayAttribute )*         '}'  ;  ScalarAttribute :   'scalar'   name = ID ;  ArrayAttribute :   'array'   name = ID   '['   dim = INT   ']' ;",
            "title": "Allow to model a mix of objects of unrelated type"
        },
        {
            "location": "/xtext_howtos/#define-multiline-string-attributes",
            "text": "You can use the \"->\" feature for terminals. You need to strip the \nleading and trailing '\"\"\"' when accessing the multiline string (e.g.,\nwith a xtend extension method).  Grammar snippet:  ...  MultlineInfo :   'info'   text = MLTEXT ;  terminal   MLTEXT :   '\"\"\"'   ->   '\"\"\"' ;   Xtend code snippet and test:  static   def   getMltext ( MultlineInfo   info )   { \n     info . text . replaceAll ( '^\"\"\"' , '' ). replaceAll ( '\"\"\"$' , '' );  }  @Test   def   void   testMlInfo ()   { \n     val   result   =   '''      info \"\"\"Hello World\"\"\"      info \"\"\"Hello Multiline      World\"\"\"      ''' . parse \n     result . assertNotNull \n     result . assertNoErrors \n     assertEquals (   '\"\"\"Hello World\"\"\"' ,   result . infos . head . text   ) \n     assertEquals (   \"Hello World\" ,   result . infos . head . mltext   ) \n     assertEquals (   \"Hello Multiline\\nWorld\" ,   result . infos . last . mltext   )  }",
            "title": "Define multiline string attributes"
        },
        {
            "location": "/xtext_howtos/#filter-a-list-based-on-a-type",
            "text": "resource . allContents . filter ( Entity )",
            "title": "Filter a list based on a type"
        },
        {
            "location": "/xtext_howtos/#filter-a-list-based-on-an-attribute-value",
            "text": "resource . allContents . filter ( Entity ). filter [ name = \"Tom\" ]",
            "title": "Filter a list based on an attribute value"
        },
        {
            "location": "/xtext_howtos/#transform-a-list",
            "text": "resource . allContents . filter ( Entity ). map [ e | 'the name is ' + e . name ]",
            "title": "Transform a list"
        },
        {
            "location": "/textx_intro/",
            "text": "TextX Intro\n\n\nTextX is a Python library to allow an easy creation of\nDSL validators and artifact generators:\n\n\n\n\nReading model files (grammar based parsing, reference resolution and post processing).\n\n\nValidating the model.\n\n\nGenerating output artifacts (e.g., code).\n\n\n\n\nA fundamental difference to Xtext is that the\nmeta model classes (describing the model elements)\nare dynamically generated instead of generating code\nfrom them. Thus, a grammar in TextX in interpreted dynamically \nand not compiled.\n\n\nTextX has only few dependencies and very compact \nprojects can be created. Details see\n\n(Dejanovi\u0107 et al. 2017)\n\nand the \"TextX project page\", see \n(TextX)\n.\n\n\nNormally, a similar modularization as for Xtext projects \nis employed to separate different responsibilities across\nsoftware modules (e.g. modules for the \ngrammar, validation, and code generation). \nHowever, it is possible to put an entire project\nincluding grammar and the validation into one file:\nthe following code illustrates a meta model with an example model\nwhich is validated (similar to the example in the \n\nintroductory example of validation\n).\n\n\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_str\n\n\nfrom\n \ntextx.scoping.providers\n \nimport\n \nRelativeName\n,\n \nFQN\n\n\nfrom\n \ntextx.export\n \nimport\n \nmodel_export\n\n\n# ------------------------------------\n\n\n# GRAMMAR\n\n\n#\n\n\nmeta_model\n \n=\n \nmetamodel_from_str\n(\n'''\n\n\n    Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;\n\n\n    Scenario: 'SCENARIO' name=ID 'BEGIN' \n\n\n        configs+=Config\n\n\n    'END';\n\n\n    Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';\n\n\n    Aspect: 'ASPECT' name=ID;\n\n\n    Testcase: 'TESTCASE' name=ID 'BEGIN'\n\n\n        'USES' scenario=[Scenario] 'WITH' config=[Config]\n\n\n        'NEEDS' '(' needs*=[Aspect] ')'\n\n\n    'END';\n\n\n    Comment: /\\/\\/.*/;\n\n\n'''\n)\n\n\n\n# ------------------------------------\n\n\n# SCOPING\n\n\n#\n\n\nmeta_model\n.\nregister_scope_providers\n({\n\n    \n'*.*'\n:\n \nFQN\n(),\n\n    \n'Testcase.config'\n:\n \nRelativeName\n(\n'scenario.configs'\n)\n\n\n})\n\n\n\n# ------------------------------------\n\n\n# VALIDATION\n\n\n#\n\n\ndef\n \ncheck_testcase\n(\ntestcase\n):\n\n    \n\"\"\"\n\n\n    checks that the config used by the testcase fulfills its needs\n\n\n    \"\"\"\n\n    \nfor\n \nneed\n \nin\n \ntestcase\n.\nneeds\n:\n\n        \nif\n \nneed\n \nnot\n \nin\n \ntestcase\n.\nconfig\n.\nhaves\n:\n\n            \nraise\n \nException\n(\n\"{}: {} not found in {}.{}\"\n.\nformat\n(\n\n                    \ntestcase\n.\nname\n,\n\n                    \nneed\n.\nname\n,\n \n                    \ntestcase\n.\nscenario\n.\nname\n,\n\n                    \ntestcase\n.\nconfig\n.\nname\n\n                    \n))\n\n\n\nmeta_model\n.\nregister_obj_processors\n({\n\n        \n'Testcase'\n:\n \ncheck_testcase\n\n\n})\n\n\n\n# ------------------------------------\n\n\n# EXAMPLE\n\n\n#\n\n\nmodel\n \n=\n \nmeta_model\n.\nmodel_from_str\n(\n'''\n\n\n    ASPECT NetworkTraffic\n\n\n    ASPECT FileAccess\n\n\n    SCENARIO S001 BEGIN\n\n\n        CONFIG HeavyNetworkTraffic HAS (NetworkTraffic)\n\n\n        CONFIG NoNetworkTraffic HAS ()\n\n\n    END\n\n\n    SCENARIO S002 BEGIN\n\n\n        CONFIG WithFileAccess HAS (NetworkTraffic FileAccess)\n\n\n        CONFIG NoFileAccess HAS (NetworkTraffic)\n\n\n    END\n\n\n    TESTCASE T001 BEGIN\n\n\n        USES S001 WITH HeavyNetworkTraffic\n\n\n        NEEDS (NetworkTraffic)\n\n\n    END\n\n\n    TESTCASE T002 BEGIN\n\n\n        //USES S001 WITH NoNetworkTraffic // Error\n\n\n        USES S002 WITH NoFileAccess\n\n\n        NEEDS (NetworkTraffic)\n\n\n    END\n\n\n'''\n)\n\n\n\nmodel_export\n(\nmodel\n,\n \n'model.dot'\n)",
            "title": "TextX Intro"
        },
        {
            "location": "/textx_intro/#textx-intro",
            "text": "TextX is a Python library to allow an easy creation of\nDSL validators and artifact generators:   Reading model files (grammar based parsing, reference resolution and post processing).  Validating the model.  Generating output artifacts (e.g., code).   A fundamental difference to Xtext is that the\nmeta model classes (describing the model elements)\nare dynamically generated instead of generating code\nfrom them. Thus, a grammar in TextX in interpreted dynamically \nand not compiled.  TextX has only few dependencies and very compact \nprojects can be created. Details see (Dejanovi\u0107 et al. 2017) \nand the \"TextX project page\", see  (TextX) .  Normally, a similar modularization as for Xtext projects \nis employed to separate different responsibilities across\nsoftware modules (e.g. modules for the \ngrammar, validation, and code generation). \nHowever, it is possible to put an entire project\nincluding grammar and the validation into one file:\nthe following code illustrates a meta model with an example model\nwhich is validated (similar to the example in the  introductory example of validation ).   from   textx   import   metamodel_from_str  from   textx.scoping.providers   import   RelativeName ,   FQN  from   textx.export   import   model_export  # ------------------------------------  # GRAMMAR  #  meta_model   =   metamodel_from_str ( '''      Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;      Scenario: 'SCENARIO' name=ID 'BEGIN'           configs+=Config      'END';      Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';      Aspect: 'ASPECT' name=ID;      Testcase: 'TESTCASE' name=ID 'BEGIN'          'USES' scenario=[Scenario] 'WITH' config=[Config]          'NEEDS' '(' needs*=[Aspect] ')'      'END';      Comment: /\\/\\/.*/;  ''' )  # ------------------------------------  # SCOPING  #  meta_model . register_scope_providers ({ \n     '*.*' :   FQN (), \n     'Testcase.config' :   RelativeName ( 'scenario.configs' )  })  # ------------------------------------  # VALIDATION  #  def   check_testcase ( testcase ): \n     \"\"\"      checks that the config used by the testcase fulfills its needs      \"\"\" \n     for   need   in   testcase . needs : \n         if   need   not   in   testcase . config . haves : \n             raise   Exception ( \"{}: {} not found in {}.{}\" . format ( \n                     testcase . name , \n                     need . name ,  \n                     testcase . scenario . name , \n                     testcase . config . name \n                     ))  meta_model . register_obj_processors ({ \n         'Testcase' :   check_testcase  })  # ------------------------------------  # EXAMPLE  #  model   =   meta_model . model_from_str ( '''      ASPECT NetworkTraffic      ASPECT FileAccess      SCENARIO S001 BEGIN          CONFIG HeavyNetworkTraffic HAS (NetworkTraffic)          CONFIG NoNetworkTraffic HAS ()      END      SCENARIO S002 BEGIN          CONFIG WithFileAccess HAS (NetworkTraffic FileAccess)          CONFIG NoFileAccess HAS (NetworkTraffic)      END      TESTCASE T001 BEGIN          USES S001 WITH HeavyNetworkTraffic          NEEDS (NetworkTraffic)      END      TESTCASE T002 BEGIN          //USES S001 WITH NoNetworkTraffic // Error          USES S002 WITH NoFileAccess          NEEDS (NetworkTraffic)      END  ''' )  model_export ( model ,   'model.dot' )",
            "title": "TextX Intro"
        },
        {
            "location": "/textx_project_setup/",
            "text": "TextX Project Setup\n\n\nWe give a guide to create a simple\ncommand line tool to load and validate a\nmodel and to generate some artifact.\n\n\nIn this example, we propose different models for\nthe \nmeta model structure\n (grammar), the \nscoping\n,\nand the \n artifact generation\n. Moreover, a \n\nmain\n and a \nsetup\n script are added to control\nthe software.\n\n\nFor this example we use Python 3. You need to install \n\n\n\n\nTextX (see \nreferences\n).\n\n\nArpeggio (see TextX in \nreferences\n)\n\n\npytest (for unittests)\n\n\n\n\nUsing pip you can:\n\n\npip3 install --upgrade textx arpeggio pytest\n\n\n\n\n\nFile structure\n\n\nAlthough everything can be packed within one file\n(see \n\"TextX Intro\"\n), the code\nis better structured into different modules \nwith individual responsibilities into different files.\n\n\n\u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 simple_dsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codegen.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 validate.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 validation.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 models\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 model_not_ok.dsl\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 model_ok.dsl\n    \u2514\u2500\u2500 test_validation.py\n\n\n\n\n\nWe have chosen a distribution as follows:\n\n\n\n\nsetup.py is the standard python project configuration\n\n\nsimple_dsl contain all dsl related logic:\n\n\ncodegen.py: code generation.\n\n\nmetamodel.py: the meta model (grammar, scoping and validation config;\n  the user classes are also stored herem but could be moved\n  elsewhere for more complex projects.   \n\n\nvalidation.py: validation logic.\n\n\nconsole/*.py: console programs (configured in setup.py).\n\n\n__init__.py represent module entry points.\n\n\n\n\n\n\ntests contains unittests.\n\n\n\n\nFile: \n metamodel.py\n\n\nHere, we define the grammar. We allocate the scope providers to\nindividual elements, and register validation code.\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_str\n\n\nfrom\n \ntextx.scoping.providers\n \nimport\n \nRelativeName\n,\n \nFQN\n\n\nimport\n \nsimple_dsl.validation\n \nas\n \nvalidation\n\n\n\ndef\n \nget_metamodel\n():\n\n    \n# GRAMMAR\n\n    \n# (you also use metamodel_from_file with a *.tx file)\n\n    \nmeta_model\n \n=\n \nmetamodel_from_str\n(\n'''\n\n\n        Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;\n\n\n        Scenario: 'SCENARIO' name=ID 'BEGIN' \n\n\n            configs+=Config\n\n\n        'END';\n\n\n        Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';\n\n\n        Aspect: 'ASPECT' name=ID;\n\n\n        Testcase: 'TESTCASE' name=ID 'BEGIN'\n\n\n            'USES' scenario=[Scenario] 'WITH' config=[Config]\n\n\n            'NEEDS' '(' needs*=[Aspect] ')'\n\n\n        'END';\n\n\n        Comment: /\\/\\/.*/;\n\n\n    '''\n)\n\n\n    \n# SCOPING\n\n    \nmeta_model\n.\nregister_scope_providers\n({\n\n        \n'*.*'\n:\n \nFQN\n(),\n\n        \n'Testcase.config'\n:\n \nRelativeName\n(\n'scenario.configs'\n)\n\n    \n})\n\n\n    \n# ADD VALIDATION\n\n    \nmeta_model\n.\nregister_obj_processors\n({\n\n            \n'Testcase'\n:\n \nvalidation\n.\ncheck_testcase\n\n    \n})\n\n\n    \nreturn\n \nmeta_model\n\n\n\n\n\n\nFile: \n validation.py\n\n\nThis file contains validation functions registered in the meta model.\n\n\nfrom\n \ntextx.exceptions\n \nimport\n \nTextXError\n\n\nfrom\n \ntextx.scoping.tools\n \nimport\n \nget_location\n\n\n\ndef\n \ncheck_testcase\n(\ntestcase\n):\n\n    \n\"\"\"\n\n\n    checks that the config used by the testcase fulfills its needs\n\n\n    \"\"\"\n\n    \nfor\n \nneed\n \nin\n \ntestcase\n.\nneeds\n:\n\n        \nif\n \nneed\n \nnot\n \nin\n \ntestcase\n.\nconfig\n.\nhaves\n:\n\n            \nraise\n \n(\nTextXError\n(\n\"{}: {} not found in {}.{}\"\n.\nformat\n(\n\n                    \ntestcase\n.\nname\n,\n\n                    \nneed\n.\nname\n,\n \n                    \ntestcase\n.\nscenario\n.\nname\n,\n\n                    \ntestcase\n.\nconfig\n.\nname\n\n                    \n),\n\n                \n**\nget_location\n(\ntestcase\n)\n \n# unpack location info\n\n            \n))\n\n\n\n\n\n\nFile: tests/test_validation.py\n\n\nThis file is a unittest using the metamodel \n(exposed via __init__.py) and checks the\ncorrect functionality of the validation code.\n\n\nfrom\n \npytest\n \nimport\n \nraises\n\n\nfrom\n \nsimple_dsl\n \nimport\n \nget_metamodel\n\n\nfrom\n \nos.path\n \nimport\n \ndirname\n,\n \njoin\n\n\nfrom\n \ntextx\n \nimport\n \nget_children_of_type\n\n\n\ndef\n \ntest_validation_ok\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nm\n \n=\n \nmm\n.\nmodel_from_file\n(\njoin\n(\ndirname\n(\n__file__\n),\n\n                            \n'models'\n,\n\n                            \n'model_ok.dsl'\n))\n\n    \nassert\n \n2\n==\nlen\n(\nget_children_of_type\n(\n'Aspect'\n,\nm\n))\n\n\n\ndef\n \ntest_validation_not_ok\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nwith\n \nraises\n(\nException\n,\n\n                \nmatch\n=\nr\n'NetworkTraffic.*not found.*S001.*NoNetworkTraffic'\n):\n\n        \n_\n \n=\n \nmm\n.\nmodel_from_file\n(\njoin\n(\ndirname\n(\n__file__\n),\n\n                                \n'models'\n,\n\n                                \n'model_not_ok.dsl'\n))\n\n\n\n\n\n\nThe two model files used in this tests are shown in the following \nsubsections.\n\n\nModel: tests/models/model_ok.dsl\n\n\nASPECT\n \nNetworkTraffic\n\n\nASPECT\n \nFileAccess\n\n\nSCENARIO\n \nS001\n \nBEGIN\n\n    \nCONFIG\n \nHeavyNetworkTraffic\n \nHAS\n \n(\nNetworkTraffic\n)\n\n    \nCONFIG\n \nNoNetworkTraffic\n \nHAS\n \n()\n\n\nEND\n\n\nSCENARIO\n \nS002\n \nBEGIN\n\n    \nCONFIG\n \nWithFileAccess\n \nHAS\n \n(\nNetworkTraffic\n \nFileAccess\n)\n\n    \nCONFIG\n \nNoFileAccess\n \nHAS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT001\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nHeavyNetworkTraffic\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT002\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nNoNetworkTraffic\n \n// Error\n\n    \n//USES S002 WITH NoFileAccess\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\n\n\n\n\nModel: tests/models/model_not_ok.dsl\n\n\nASPECT\n \nNetworkTraffic\n\n\nASPECT\n \nFileAccess\n\n\nSCENARIO\n \nS001\n \nBEGIN\n\n    \nCONFIG\n \nHeavyNetworkTraffic\n \nHAS\n \n(\nNetworkTraffic\n)\n\n    \nCONFIG\n \nNoNetworkTraffic\n \nHAS\n \n()\n\n\nEND\n\n\nSCENARIO\n \nS002\n \nBEGIN\n\n    \nCONFIG\n \nWithFileAccess\n \nHAS\n \n(\nNetworkTraffic\n \nFileAccess\n)\n\n    \nCONFIG\n \nNoFileAccess\n \nHAS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT001\n \nBEGIN\n\n    \nUSES\n \nS001\n \nWITH\n \nHeavyNetworkTraffic\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\nTESTCASE\n \nT002\n \nBEGIN\n\n    \n//USES S001 WITH NoNetworkTraffic // Error\n\n    \nUSES\n \nS002\n \nWITH\n \nNoFileAccess\n\n    \nNEEDS\n \n(\nNetworkTraffic\n)\n\n\nEND\n\n\n\n\n\n\nEdit, Run and Test\n\n\nUse an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your \nnew language.\n\n\nInstall/Uninstall the Language\n\n\nAfter all tests passed you can try to install your language.\nDo not forget to adapt setup.py:\n\n\nfrom\n \nsetuptools\n \nimport\n \nsetup\n,\nfind_packages\n\n\n\nsetup\n(\nname\n=\n'simple_dsl'\n,\n\n      \nversion\n=\n'0.1'\n,\n\n      \ndescription\n=\n'a simple model validator and artifact compiler'\n,\n\n      \nurl\n=\n''\n,\n\n      \nauthor\n=\n'YOUR NAME'\n,\n\n      \nauthor_email\n=\n'YOUR.NAME@ADDRESS'\n,\n\n      \nlicense\n=\n'TODO'\n,\n\n      \npackages\n=\nfind_packages\n(),\n\n      \npackage_data\n=\n{\n''\n:\n \n[\n'*.tx'\n,\n \n'*.template'\n,\n \n'support_*_code/**/*'\n]},\n\n      \ninstall_requires\n=\n[\n\"textx\"\n,\n\"arpeggio\"\n],\n\n      \ntests_require\n=\n[\n\n          \n'pytest'\n,\n\n      \n],\n\n      \nkeywords\n=\n\"parser meta-language meta-model language DSL\"\n,\n\n      \nentry_points\n=\n{\n\n          \n'console_scripts'\n:\n \n[\n\n              \n'simple_dsl_validate=simple_dsl.console.validate:validate'\n,\n\n          \n]\n\n      \n},\n\n      \n)\n\n\n\n\n# to play around without installing: do \"export PYTHONPATH=.\"\n\n\n\n\n\n\nThe registered console command (validate.py) contains:\n\n\nimport\n \nargparse\n\n\nfrom\n \nsimple_dsl\n \nimport\n \nget_metamodel\n\n\n\ndef\n \nvalidate\n():\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n    \nparser\n \n=\n \nargparse\n.\nArgumentParser\n(\ndescription\n=\n'validate simple_dsl files.'\n)\n\n    \nparser\n.\nadd_argument\n(\n'model_files'\n,\n \nmetavar\n=\n'model_files'\n,\n \ntype\n=\nstr\n,\n\n                        \nnargs\n=\n'+'\n,\n\n                        \nhelp\n=\n'model filenames'\n)\n\n    \nargs\n \n=\n \nparser\n.\nparse_args\n()\n\n\n    \nfor\n \nfilename\n \nin\n \nargs\n.\nmodel_files\n:\n\n        \ntry\n:\n\n            \nprint\n(\n'validating {}'\n.\nformat\n(\nfilename\n))\n\n            \n_\n \n=\n \nmm\n.\nmodel_from_file\n(\nfilename\n)\n\n        \nexcept\n \nBaseException\n \nas\n \ne\n:\n\n            \nprint\n(\n'  WARNING/ERROR: {}'\n.\nformat\n(\ne\n))\n\n\n\n\nif\n \n__name__\n==\n'__main__'\n:\n\n    \nvalidate\n()\n\n\n\n\n\n\nInstallation\n\n\nInstall\n the software \npermanently for all users\n (change directory\nto the folder with the setup.py file):\n\n\nsudo -H pip3 install --upgrade .\n\n\n\n\n\nYou can now start the new commands defined in the setup.py: \n\n\nsimple_dsl_validate --help\n\n\n\n\n\nUninstallation\n\n\nUninstall\n the software:\n\n\nsudo -H pip3 uninstall simple_dsl",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#textx-project-setup",
            "text": "We give a guide to create a simple\ncommand line tool to load and validate a\nmodel and to generate some artifact.  In this example, we propose different models for\nthe  meta model structure  (grammar), the  scoping ,\nand the   artifact generation . Moreover, a  main  and a  setup  script are added to control\nthe software.  For this example we use Python 3. You need to install    TextX (see  references ).  Arpeggio (see TextX in  references )  pytest (for unittests)   Using pip you can:  pip3 install --upgrade textx arpeggio pytest",
            "title": "TextX Project Setup"
        },
        {
            "location": "/textx_project_setup/#file-structure",
            "text": "Although everything can be packed within one file\n(see  \"TextX Intro\" ), the code\nis better structured into different modules \nwith individual responsibilities into different files.  \u251c\u2500\u2500 setup.py\n\u251c\u2500\u2500 simple_dsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 codegen.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 console\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 validate.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 validation.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 models\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 model_not_ok.dsl\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 model_ok.dsl\n    \u2514\u2500\u2500 test_validation.py  We have chosen a distribution as follows:   setup.py is the standard python project configuration  simple_dsl contain all dsl related logic:  codegen.py: code generation.  metamodel.py: the meta model (grammar, scoping and validation config;\n  the user classes are also stored herem but could be moved\n  elsewhere for more complex projects.     validation.py: validation logic.  console/*.py: console programs (configured in setup.py).  __init__.py represent module entry points.    tests contains unittests.",
            "title": "File structure"
        },
        {
            "location": "/textx_project_setup/#file-metamodelpy",
            "text": "Here, we define the grammar. We allocate the scope providers to\nindividual elements, and register validation code.  from   textx   import   metamodel_from_str  from   textx.scoping.providers   import   RelativeName ,   FQN  import   simple_dsl.validation   as   validation  def   get_metamodel (): \n     # GRAMMAR \n     # (you also use metamodel_from_file with a *.tx file) \n     meta_model   =   metamodel_from_str ( '''          Model: aspects+=Aspect scenarios+=Scenario testcases+=Testcase;          Scenario: 'SCENARIO' name=ID 'BEGIN'               configs+=Config          'END';          Config: 'CONFIG' name=ID 'HAS' '(' haves*=[Aspect] ')';          Aspect: 'ASPECT' name=ID;          Testcase: 'TESTCASE' name=ID 'BEGIN'              'USES' scenario=[Scenario] 'WITH' config=[Config]              'NEEDS' '(' needs*=[Aspect] ')'          'END';          Comment: /\\/\\/.*/;      ''' ) \n\n     # SCOPING \n     meta_model . register_scope_providers ({ \n         '*.*' :   FQN (), \n         'Testcase.config' :   RelativeName ( 'scenario.configs' ) \n     }) \n\n     # ADD VALIDATION \n     meta_model . register_obj_processors ({ \n             'Testcase' :   validation . check_testcase \n     }) \n\n     return   meta_model",
            "title": "File: "
        },
        {
            "location": "/textx_project_setup/#file-validationpy",
            "text": "This file contains validation functions registered in the meta model.  from   textx.exceptions   import   TextXError  from   textx.scoping.tools   import   get_location  def   check_testcase ( testcase ): \n     \"\"\"      checks that the config used by the testcase fulfills its needs      \"\"\" \n     for   need   in   testcase . needs : \n         if   need   not   in   testcase . config . haves : \n             raise   ( TextXError ( \"{}: {} not found in {}.{}\" . format ( \n                     testcase . name , \n                     need . name ,  \n                     testcase . scenario . name , \n                     testcase . config . name \n                     ), \n                 ** get_location ( testcase )   # unpack location info \n             ))",
            "title": "File: "
        },
        {
            "location": "/textx_project_setup/#file-teststest_validationpy",
            "text": "This file is a unittest using the metamodel \n(exposed via __init__.py) and checks the\ncorrect functionality of the validation code.  from   pytest   import   raises  from   simple_dsl   import   get_metamodel  from   os.path   import   dirname ,   join  from   textx   import   get_children_of_type  def   test_validation_ok (): \n     mm   =   get_metamodel () \n     m   =   mm . model_from_file ( join ( dirname ( __file__ ), \n                             'models' , \n                             'model_ok.dsl' )) \n     assert   2 == len ( get_children_of_type ( 'Aspect' , m ))  def   test_validation_not_ok (): \n     mm   =   get_metamodel () \n     with   raises ( Exception , \n                 match = r 'NetworkTraffic.*not found.*S001.*NoNetworkTraffic' ): \n         _   =   mm . model_from_file ( join ( dirname ( __file__ ), \n                                 'models' , \n                                 'model_not_ok.dsl' ))   The two model files used in this tests are shown in the following \nsubsections.",
            "title": "File: tests/test_validation.py"
        },
        {
            "location": "/textx_project_setup/#model-testsmodelsmodel_okdsl",
            "text": "ASPECT   NetworkTraffic  ASPECT   FileAccess  SCENARIO   S001   BEGIN \n     CONFIG   HeavyNetworkTraffic   HAS   ( NetworkTraffic ) \n     CONFIG   NoNetworkTraffic   HAS   ()  END  SCENARIO   S002   BEGIN \n     CONFIG   WithFileAccess   HAS   ( NetworkTraffic   FileAccess ) \n     CONFIG   NoFileAccess   HAS   ( NetworkTraffic )  END  TESTCASE   T001   BEGIN \n     USES   S001   WITH   HeavyNetworkTraffic \n     NEEDS   ( NetworkTraffic )  END  TESTCASE   T002   BEGIN \n     USES   S001   WITH   NoNetworkTraffic   // Error \n     //USES S002 WITH NoFileAccess \n     NEEDS   ( NetworkTraffic )  END",
            "title": "Model: tests/models/model_ok.dsl"
        },
        {
            "location": "/textx_project_setup/#model-testsmodelsmodel_not_okdsl",
            "text": "ASPECT   NetworkTraffic  ASPECT   FileAccess  SCENARIO   S001   BEGIN \n     CONFIG   HeavyNetworkTraffic   HAS   ( NetworkTraffic ) \n     CONFIG   NoNetworkTraffic   HAS   ()  END  SCENARIO   S002   BEGIN \n     CONFIG   WithFileAccess   HAS   ( NetworkTraffic   FileAccess ) \n     CONFIG   NoFileAccess   HAS   ( NetworkTraffic )  END  TESTCASE   T001   BEGIN \n     USES   S001   WITH   HeavyNetworkTraffic \n     NEEDS   ( NetworkTraffic )  END  TESTCASE   T002   BEGIN \n     //USES S001 WITH NoNetworkTraffic // Error \n     USES   S002   WITH   NoFileAccess \n     NEEDS   ( NetworkTraffic )  END",
            "title": "Model: tests/models/model_not_ok.dsl"
        },
        {
            "location": "/textx_project_setup/#edit-run-and-test",
            "text": "Use an appropriate IDE (e.g., PyCharm) to run the tests and, thus, test and debug your \nnew language.",
            "title": "Edit, Run and Test"
        },
        {
            "location": "/textx_project_setup/#installuninstall-the-language",
            "text": "After all tests passed you can try to install your language.\nDo not forget to adapt setup.py:  from   setuptools   import   setup , find_packages  setup ( name = 'simple_dsl' , \n       version = '0.1' , \n       description = 'a simple model validator and artifact compiler' , \n       url = '' , \n       author = 'YOUR NAME' , \n       author_email = 'YOUR.NAME@ADDRESS' , \n       license = 'TODO' , \n       packages = find_packages (), \n       package_data = { '' :   [ '*.tx' ,   '*.template' ,   'support_*_code/**/*' ]}, \n       install_requires = [ \"textx\" , \"arpeggio\" ], \n       tests_require = [ \n           'pytest' , \n       ], \n       keywords = \"parser meta-language meta-model language DSL\" , \n       entry_points = { \n           'console_scripts' :   [ \n               'simple_dsl_validate=simple_dsl.console.validate:validate' , \n           ] \n       }, \n       )  # to play around without installing: do \"export PYTHONPATH=.\"   The registered console command (validate.py) contains:  import   argparse  from   simple_dsl   import   get_metamodel  def   validate (): \n     mm   =   get_metamodel () \n     parser   =   argparse . ArgumentParser ( description = 'validate simple_dsl files.' ) \n     parser . add_argument ( 'model_files' ,   metavar = 'model_files' ,   type = str , \n                         nargs = '+' , \n                         help = 'model filenames' ) \n     args   =   parser . parse_args () \n\n     for   filename   in   args . model_files : \n         try : \n             print ( 'validating {}' . format ( filename )) \n             _   =   mm . model_from_file ( filename ) \n         except   BaseException   as   e : \n             print ( '  WARNING/ERROR: {}' . format ( e ))  if   __name__ == '__main__' : \n     validate ()",
            "title": "Install/Uninstall the Language"
        },
        {
            "location": "/textx_project_setup/#installation",
            "text": "Install  the software  permanently for all users  (change directory\nto the folder with the setup.py file):  sudo -H pip3 install --upgrade .  You can now start the new commands defined in the setup.py:   simple_dsl_validate --help",
            "title": "Installation"
        },
        {
            "location": "/textx_project_setup/#uninstallation",
            "text": "Uninstall  the software:  sudo -H pip3 uninstall simple_dsl",
            "title": "Uninstallation"
        },
        {
            "location": "/textx_by_examples/",
            "text": "TextX by Examples\n\n\nThe TextX project page gives a nice introduction \nto the concepts of TextX \n(TextX)\n.\nRead the docs to explore different aspects, like\nthe grammar or scoping. The unittests are\nalso a great source of information, because they contain\nmany examples for different topics.\n\n\nNote: validators are implemented as so-called object_processors.\nThese object_processors are meant to post process the\nparsed model (possibly modifying the model). They can also\nbe used to raise exceptions in order to indicate a logical\ndomain error (as in the \ninitial example\n).",
            "title": "TextX by Examples"
        },
        {
            "location": "/textx_by_examples/#textx-by-examples",
            "text": "The TextX project page gives a nice introduction \nto the concepts of TextX  (TextX) .\nRead the docs to explore different aspects, like\nthe grammar or scoping. The unittests are\nalso a great source of information, because they contain\nmany examples for different topics.  Note: validators are implemented as so-called object_processors.\nThese object_processors are meant to post process the\nparsed model (possibly modifying the model). They can also\nbe used to raise exceptions in order to indicate a logical\ndomain error (as in the  initial example ).",
            "title": "TextX by Examples"
        },
        {
            "location": "/textx_modularization/",
            "text": "TextX: Model Modularization\n\n\nSimilar to \nxtext_modularization.md\n, we \nshow how to achive model modularization across files in TextX.\n\n\nModularization within the same Meta Model\n\n\nReady to use scope providers exists to handle multiple files. See the\n\n(TextX)\n) documentation for details.\n\n\nReferencing Model Elements form other Meta Models\n\n\nIf yuo wish to reference model elements from other metamodels, this can be \nachieved using the multi meta model support of TextX \n(see \n(TextX)\n).\n\n\nThe following example is self contained and shows how to deploy two\npython packages for two DSLs, one referencing the other.\n\n\nmydsl - a simple model of \"Greetings\"\n\n\nFile layout\n\n\n\u251c\u2500\u2500 mydsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 MyDsl.tx\n\u2514\u2500\u2500 setup.py\n\n\n\n\n\nGrammar MyDsl.tx\n\n\nModel\n:\n \ngreetings\n+=\nGreeting\n;\n\n\nGreeting\n:\n \n'Hello'\n \nname\n=\nID\n'!'\n;\n\n\n\n\n\n\nmetamodel.py\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_file\n\n\nfrom\n \nos.path\n \nimport\n \ndirname\n,\n \nabspath\n,\n \njoin\n\n\n\ndef\n \nget_metamodel\n():\n\n    \nthis_folder\n \n=\n \ndirname\n(\nabspath\n(\n__file__\n))\n\n    \nmeta_model\n \n=\n \nmetamodel_from_file\n(\njoin\n(\nthis_folder\n,\n\"MyDsl.tx\"\n))\n\n    \nreturn\n \nmeta_model\n\n\n\n\n\n\n__init__.py\n\n\nimport\n \nargparse\n\n\nfrom\n \nmydsl.metamodel\n \nimport\n \nget_metamodel\n\n\n\ndef\n \nmydslc\n():\n\n    \nparser\n \n=\n \nargparse\n.\nArgumentParser\n(\ndescription\n=\n'generate code for the model.'\n)\n\n    \nparser\n.\nadd_argument\n(\n'model_files'\n,\n \nmetavar\n=\n'model_files'\n,\n \ntype\n=\nstr\n,\n \nnargs\n=\n'+'\n,\n\n                        \nhelp\n=\n'model filenames'\n)\n\n\n    \nargs\n \n=\n \nparser\n.\nparse_args\n()\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n\n    \nfor\n \nmodel_file\n \nin\n \nargs\n.\nmodel_files\n:\n\n        \nmodel\n \n=\n \nmm\n.\nmodel_from_file\n(\nmodel_file\n)\n\n        \nfor\n \ngreeting\n \nin\n \nmodel\n.\ngreetings\n:\n\n            \nprint\n(\n\" - hello for '{}'\"\n.\nformat\n(\ngreeting\n.\nname\n))\n\n\n\n\n\n\nCreate installer\n\n\nCreate an installer to help pip find its dependencies:\n\n\npython setup.py  sdist\n\n\n\n\n\nmydsl1 - a model referencing the \"Greetings\" from mydsl\n\n\nFile layout\n\n\n\u251c\u2500\u2500 mydsl1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 MyDsl1.tx\n\u2514\u2500\u2500 setup.py\n\n\n\n\n\nGrammar MyDsl1.tx\n\n\nNote: we use the grammar rule \"Greeting\" from \"mydsl\". See metamodel.py how\nthis is resolved (\"refrenced_metamodels\").\n\n\nModel\n:\n \nimports\n+=\nImport\n \ngreetings\n+=\nRefGreeting\n;\n\n\nRefGreeting\n:\n \n'Hello'\n \n'-->'\n \nref\n=\n[\nGreeting\n];\n\n\nImport\n:\n \n'import'\n \nimportURI\n=\nSTRING\n;\n\n\n\n\n\n\nmetamodel.py\n\n\nfrom\n \ntextx\n \nimport\n \nmetamodel_from_file\n\n\nimport\n \ntextx.scoping\n \nas\n \nscoping\n\n\nimport\n \ntextx.scoping.providers\n \nas\n \nscoping_providers\n\n\nfrom\n \nos.path\n \nimport\n \ndirname\n,\n \nabspath\n,\n \njoin\n\n\nimport\n \nmydsl\n\n\n\ndef\n \nget_metamodel\n():\n\n    \nthis_folder\n \n=\n \ndirname\n(\nabspath\n(\n__file__\n))\n\n\n    \n# get the \"mydsl\" meta model\n\n    \nother_meta_model\n \n=\n \nmydsl\n.\nget_metamodel\n()\n\n\n    \n# create the meta model and reference \"mydsl\"\n\n    \nmeta_model\n \n=\n \nmetamodel_from_file\n(\n\n        \njoin\n(\nthis_folder\n,\n\"MyDsl1.tx\"\n),\n \n        \nreferenced_metamodels\n=\n[\nother_meta_model\n])\n\n\n    \n# register scope provider (allow import models into mydsl1 models)\n\n    \nmeta_model\n.\nregister_scope_providers\n(\n\n        \n{\n\"*.*\"\n:\n \nscoping_providers\n.\nPlainNameImportURI\n()})\n\n\n    \n# register file endings\n\n    \nscoping\n.\nMetaModelProvider\n.\nadd_metamodel\n(\n\"*.mydsl\"\n,\n \nother_meta_model\n)\n\n    \nscoping\n.\nMetaModelProvider\n.\nadd_metamodel\n(\n\"*.mydsl1\"\n,\n \nmeta_model\n)\n\n\n    \nreturn\n \nmeta_model\n\n\n\n\n\n\n__init__.py\n\n\nimport\n \nargparse\n\n\nfrom\n \nmydsl1.metamodel\n \nimport\n \nget_metamodel\n\n\n\ndef\n \nmydsl1c\n():\n\n    \nparser\n \n=\n \nargparse\n.\nArgumentParser\n(\ndescription\n=\n'generate code for the model.'\n)\n\n    \nparser\n.\nadd_argument\n(\n'model_files'\n,\n \nmetavar\n=\n'model_files'\n,\n \ntype\n=\nstr\n,\n \nnargs\n=\n'+'\n,\n\n                        \nhelp\n=\n'model filenames'\n)\n\n\n    \nargs\n \n=\n \nparser\n.\nparse_args\n()\n\n    \nmm\n \n=\n \nget_metamodel\n()\n\n\n    \nfor\n \nmodel_file\n \nin\n \nargs\n.\nmodel_files\n:\n\n        \nmodel\n \n=\n \nmm\n.\nmodel_from_file\n(\nmodel_file\n)\n\n        \nfor\n \ngreeting\n \nin\n \nmodel\n.\ngreetings\n:\n\n            \nprint\n(\n\" - hello for referenced '{}'\"\n.\nformat\n(\ngreeting\n.\nref\n.\nname\n))\n\n\n\n\n\n\nInstaller bother DSLs and compilers\n\n\nThe option \"find-links\" is used to point to the local version of \nmydsl (created above; setup.py of \"mydsl1\" includes this dependency):\n\n\npip3 install . --find-links\n=\nfile:///\n$(\npwd\n)\n/../mydsl/dist\n\n\n\n\n\nUsage\n\n\nModel file data.mydsl\n\n\nHello\n \nPi\n!\n\n\nHello\n \nTim\n!\n\n\n\n\n\n\nModel file data.mydsl1\n\n\nimport\n \n\"\ndata.mydsl\n\"\n\n\nHello\n \n-->\n \nPi\n\n\nHello\n \n-->\n \nTim\n\n\n\n\n\n\nModel file error.mydsl1\n\n\nimport\n \n\"\ndata.mydsl\n\"\n\n\nHello\n \n-->\n \nNoName\n\n\n\n\n\n\nExample using mydslc and mydsl1c\n\n\n$ mydslc model/data.mydsl\n - hello \nfor\n \n'Pi'\n\n - hello \nfor\n \n'Tim'\n\n$ mydsl1c model/data.mydsl1\n - hello \nfor\n referenced \n'Pi'\n\n - hello \nfor\n referenced \n'Tim'\n\n$ mydsl1c model/error.mydsl1\n...\ntextx.exceptions.TextXSemanticError: model/error.mydsl1:2:11: \nerror: Unknown object \n\"NoName\"\n of class \n\"Greeting\"",
            "title": "TextX Modularization"
        },
        {
            "location": "/textx_modularization/#textx-model-modularization",
            "text": "Similar to  xtext_modularization.md , we \nshow how to achive model modularization across files in TextX.",
            "title": "TextX: Model Modularization"
        },
        {
            "location": "/textx_modularization/#modularization-within-the-same-meta-model",
            "text": "Ready to use scope providers exists to handle multiple files. See the (TextX) ) documentation for details.",
            "title": "Modularization within the same Meta Model"
        },
        {
            "location": "/textx_modularization/#referencing-model-elements-form-other-meta-models",
            "text": "If yuo wish to reference model elements from other metamodels, this can be \nachieved using the multi meta model support of TextX \n(see  (TextX) ).  The following example is self contained and shows how to deploy two\npython packages for two DSLs, one referencing the other.",
            "title": "Referencing Model Elements form other Meta Models"
        },
        {
            "location": "/textx_modularization/#mydsl-a-simple-model-of-greetings",
            "text": "",
            "title": "mydsl - a simple model of \"Greetings\""
        },
        {
            "location": "/textx_modularization/#file-layout",
            "text": "\u251c\u2500\u2500 mydsl\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 MyDsl.tx\n\u2514\u2500\u2500 setup.py",
            "title": "File layout"
        },
        {
            "location": "/textx_modularization/#grammar-mydsltx",
            "text": "Model :   greetings += Greeting ;  Greeting :   'Hello'   name = ID '!' ;",
            "title": "Grammar MyDsl.tx"
        },
        {
            "location": "/textx_modularization/#metamodelpy",
            "text": "from   textx   import   metamodel_from_file  from   os.path   import   dirname ,   abspath ,   join  def   get_metamodel (): \n     this_folder   =   dirname ( abspath ( __file__ )) \n     meta_model   =   metamodel_from_file ( join ( this_folder , \"MyDsl.tx\" )) \n     return   meta_model",
            "title": "metamodel.py"
        },
        {
            "location": "/textx_modularization/#9595init9595py",
            "text": "import   argparse  from   mydsl.metamodel   import   get_metamodel  def   mydslc (): \n     parser   =   argparse . ArgumentParser ( description = 'generate code for the model.' ) \n     parser . add_argument ( 'model_files' ,   metavar = 'model_files' ,   type = str ,   nargs = '+' , \n                         help = 'model filenames' ) \n\n     args   =   parser . parse_args () \n     mm   =   get_metamodel () \n\n     for   model_file   in   args . model_files : \n         model   =   mm . model_from_file ( model_file ) \n         for   greeting   in   model . greetings : \n             print ( \" - hello for '{}'\" . format ( greeting . name ))",
            "title": "__init__.py"
        },
        {
            "location": "/textx_modularization/#create-installer",
            "text": "Create an installer to help pip find its dependencies:  python setup.py  sdist",
            "title": "Create installer"
        },
        {
            "location": "/textx_modularization/#mydsl1-a-model-referencing-the-greetings-from-mydsl",
            "text": "",
            "title": "mydsl1 - a model referencing the \"Greetings\" from mydsl"
        },
        {
            "location": "/textx_modularization/#file-layout_1",
            "text": "\u251c\u2500\u2500 mydsl1\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 metamodel.py\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 MyDsl1.tx\n\u2514\u2500\u2500 setup.py",
            "title": "File layout"
        },
        {
            "location": "/textx_modularization/#grammar-mydsl1tx",
            "text": "Note: we use the grammar rule \"Greeting\" from \"mydsl\". See metamodel.py how\nthis is resolved (\"refrenced_metamodels\").  Model :   imports += Import   greetings += RefGreeting ;  RefGreeting :   'Hello'   '-->'   ref = [ Greeting ];  Import :   'import'   importURI = STRING ;",
            "title": "Grammar MyDsl1.tx"
        },
        {
            "location": "/textx_modularization/#metamodelpy_1",
            "text": "from   textx   import   metamodel_from_file  import   textx.scoping   as   scoping  import   textx.scoping.providers   as   scoping_providers  from   os.path   import   dirname ,   abspath ,   join  import   mydsl  def   get_metamodel (): \n     this_folder   =   dirname ( abspath ( __file__ )) \n\n     # get the \"mydsl\" meta model \n     other_meta_model   =   mydsl . get_metamodel () \n\n     # create the meta model and reference \"mydsl\" \n     meta_model   =   metamodel_from_file ( \n         join ( this_folder , \"MyDsl1.tx\" ),  \n         referenced_metamodels = [ other_meta_model ]) \n\n     # register scope provider (allow import models into mydsl1 models) \n     meta_model . register_scope_providers ( \n         { \"*.*\" :   scoping_providers . PlainNameImportURI ()}) \n\n     # register file endings \n     scoping . MetaModelProvider . add_metamodel ( \"*.mydsl\" ,   other_meta_model ) \n     scoping . MetaModelProvider . add_metamodel ( \"*.mydsl1\" ,   meta_model ) \n\n     return   meta_model",
            "title": "metamodel.py"
        },
        {
            "location": "/textx_modularization/#9595init9595py_1",
            "text": "import   argparse  from   mydsl1.metamodel   import   get_metamodel  def   mydsl1c (): \n     parser   =   argparse . ArgumentParser ( description = 'generate code for the model.' ) \n     parser . add_argument ( 'model_files' ,   metavar = 'model_files' ,   type = str ,   nargs = '+' , \n                         help = 'model filenames' ) \n\n     args   =   parser . parse_args () \n     mm   =   get_metamodel () \n\n     for   model_file   in   args . model_files : \n         model   =   mm . model_from_file ( model_file ) \n         for   greeting   in   model . greetings : \n             print ( \" - hello for referenced '{}'\" . format ( greeting . ref . name ))",
            "title": "__init__.py"
        },
        {
            "location": "/textx_modularization/#installer-bother-dsls-and-compilers",
            "text": "The option \"find-links\" is used to point to the local version of \nmydsl (created above; setup.py of \"mydsl1\" includes this dependency):  pip3 install . --find-links = file:/// $( pwd ) /../mydsl/dist",
            "title": "Installer bother DSLs and compilers"
        },
        {
            "location": "/textx_modularization/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/textx_modularization/#model-file-datamydsl",
            "text": "Hello   Pi !  Hello   Tim !",
            "title": "Model file data.mydsl"
        },
        {
            "location": "/textx_modularization/#model-file-datamydsl1",
            "text": "import   \" data.mydsl \"  Hello   -->   Pi  Hello   -->   Tim",
            "title": "Model file data.mydsl1"
        },
        {
            "location": "/textx_modularization/#model-file-errormydsl1",
            "text": "import   \" data.mydsl \"  Hello   -->   NoName",
            "title": "Model file error.mydsl1"
        },
        {
            "location": "/textx_modularization/#example-using-mydslc-and-mydsl1c",
            "text": "$ mydslc model/data.mydsl\n - hello  for   'Pi' \n - hello  for   'Tim' \n$ mydsl1c model/data.mydsl1\n - hello  for  referenced  'Pi' \n - hello  for  referenced  'Tim' \n$ mydsl1c model/error.mydsl1\n...\ntextx.exceptions.TextXSemanticError: model/error.mydsl1:2:11: \nerror: Unknown object  \"NoName\"  of class  \"Greeting\"",
            "title": "Example using mydslc and mydsl1c"
        },
        {
            "location": "/references/",
            "text": "References\n\n\nMany websites, books and persons influenced this work.\nThe references are summarized in the following sections.\n\n\nToolsets / Language Workbenches\n\n\n\n\n (Xtext) \nXtext\n - a grammar based language workbench for java/Xtend/eclipse.\n\n\n (TextX) \nTextX\n - a grammar based language workbench for Python.\n\n\n\n\nProgramming languages, Tools\n\n\n\n\n (Maven) \nMaven\n - a build system\n\n\nXtend\n - a statically types language (translates to Java).\n\n\nPython\n - a dynamically types language.\n\n\n\n\nGeneral information\n\n\n\n\n (Tomassetti, 2017) F. Tomassetti: \n\"The complete guide to (external) Domain Specific Languages\"\n (06/2018)\n\n\n\n\nXtext related stuff\n\n\n\n\n (Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).\n\n\n (Mooij et al, 2017a) A. Mooij, J. Hooman: \n\"Creating a Domain Specific Language (DSL) with Xtext\"\n (2017/06)\n\n\n (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman: \n\"Advanced Xtext Manual on Modularity\"\n (2017/06)\n\n\n (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of \neTrice (ROOM based modeling tool)\n (2017/06)\n\n\n (Xtext 15 Minutes Tutorial) \nXtext 15 Minutes Tutorial\n.\n\n\n (Xtext 15 Minutes Tutorial, Extended) \nXtext 15 Minutes Tutorial, Extended\n.\n\n\n\n\nTextX related stuff\n\n\n\n\n (Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "References"
        },
        {
            "location": "/references/#references",
            "text": "Many websites, books and persons influenced this work.\nThe references are summarized in the following sections.",
            "title": "References"
        },
        {
            "location": "/references/#toolsets-language-workbenches",
            "text": "(Xtext)  Xtext  - a grammar based language workbench for java/Xtend/eclipse.   (TextX)  TextX  - a grammar based language workbench for Python.",
            "title": "Toolsets / Language Workbenches"
        },
        {
            "location": "/references/#programming-languages-tools",
            "text": "(Maven)  Maven  - a build system  Xtend  - a statically types language (translates to Java).  Python  - a dynamically types language.",
            "title": "Programming languages, Tools"
        },
        {
            "location": "/references/#general-information",
            "text": "(Tomassetti, 2017) F. Tomassetti:  \"The complete guide to (external) Domain Specific Languages\"  (06/2018)",
            "title": "General information"
        },
        {
            "location": "/references/#xtext-related-stuff",
            "text": "(Bettini, 2016) L. Bettini: \"Implementing Domain-Specific Languages with Xtext and Xtend - Second Edition\u201c (Packt Publishing; 2nd Revised edition, 31. August 2016).   (Mooij et al, 2017a) A. Mooij, J. Hooman:  \"Creating a Domain Specific Language (DSL) with Xtext\"  (2017/06)   (Mooij et al, 2017b) A. Mooij, K. Triantafyllidis, J. Hooman:  \"Advanced Xtext Manual on Modularity\"  (2017/06)   (Rentz-Reichert, 2017) H. Rentz-Reichert (Protos Software): \"Entwicklung dom\u00e4nenspezifischer Sprachen und Code-Generatoren mit Xtext und Xtend\" (german course, Regensburg, 2017/05;\n    architect of  eTrice (ROOM based modeling tool)  (2017/06)   (Xtext 15 Minutes Tutorial)  Xtext 15 Minutes Tutorial .   (Xtext 15 Minutes Tutorial, Extended)  Xtext 15 Minutes Tutorial, Extended .",
            "title": "Xtext related stuff"
        },
        {
            "location": "/references/#textx-related-stuff",
            "text": "(Dejanovi\u0107 et al. 2017) Dejanovi\u0107 I., Vaderna R., Milosavljevi\u0107 G., Vukovi\u0107 \u017d. (2017). TextX: A Python tool for Domain-Specific Languages implementation. Knowledge-Based Systems, 115, 1-4.",
            "title": "TextX related stuff"
        }
    ]
}